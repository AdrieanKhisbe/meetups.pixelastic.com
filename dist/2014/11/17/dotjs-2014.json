{
  "id": "/2014/11/17/dotjs-2014",
  "title": "dotJS 2014",
  "url": "http://meetups.pixelastic.com//2014/11/17/dotjs-2014/",
  "tags": [
    "dotjs"
  ],
  "date": 1416178800,
  "html": "<p>Le 19 Novembre 2014, au <a href=\"http://www.theatredeparis.com/\">Théatre de Paris</a>,\navait lieu la nouvelle édition de <a href=\"http://www.dotjs.eu/\">dotJS</a>. Un lieu\nmagnifique, des speakers de renom et des présentations intéressantes. Je n&#39;ai\npas réussi à sortir un fil directeur général au programme, mais voici un petit\nrésumé des différentes conférences.</p>\n\n<p>C&#39;est dans l&#39;ordre chronologique de la journée, mais sans doute un peu en vrac\ndans les idées.</p>\n\n<h2>James Halliday aka Substack</h2>\n\n<p><iframe 
class="youtube-player"
type="text/html" 
width="640" 
height="390"
src="http://www.youtube.com/embed/J9_VaU4N3Rg"
frameborder="0"
allowfullscreen
></iframe></p>\n\n<p><a href=\"https://twitter.com/substack\">Substack</a>, le mec qui code même dans son sommeil\n(jetez un œil à <a href=\"https://github.com/substack\">sa timeline</a>), nous a parlé de...\nplein de choses. Je suis pas sur de pouvoir en ressortir le propos exact, mais\nj&#39;ai beaucoup apprécié le personnage et la session de questions-réponses qui\na suivi son intervention.</p>\n\n<p>Il a commencé à nous parler de comment réussir à avoir une\napplication web qui puisse fonctionner complétement offline, avec le mode\nonline qui soit simplement un bonus. Pour ça, on passe par un cache manifest,\nqui définit la liste des éléments qui doivent être gardés pour le mode offline.\nEt si on veut aller encore plus loin, on mets carrément le cache manifest dans\nle cache manifest, comme ça on est sur que notre appli ne se connectera pas.</p>\n\n<p>Il a ensuite énoncé quelque chose de très vrai : un site offline est le\nmeilleur moyen d&#39;avoir un scaling infini. Zero requête vers le serveur, pas de\nproblème de charge, il peut y avoir une infinité de personnes qui utilisent le\nsite en même temps, cela n&#39;influera en rien sur ses fonctionnalités.</p>\n\n<p>Il a développé, comme à son habitude, un ensemble de modules pour aller dans\ncette direction. L&#39;un d&#39;eux utilise <code>localStorage</code> pour garder un historique des\nanciennes versions du site directement dans le browser. Il est ainsi possible\nde revenir à des versions de la veille ou de la semaine dernière à partir du\nmoment où on les a déjà téléchargé une fois.</p>\n\n<p>S&#39;en vient ensuite la question de l&#39;authentication quand on n&#39;a pas de serveur\ndistant ? En utilisant les méthodes de crypto définies dans <code>crypto.subtle</code>, on\npeut réussir à faire une grosse partie de l&#39;authent directement dans le\nbrowser.</p>\n\n<p>Il a finalement parlé d&#39;un autre de ses modules,\n<a href=\"https://github.com/substack/forkdb\">forkdb</a>, qui semble\nfonctionner comme un database key/value, mais où chaque value contient un hash\ndes metadata de son historique, permettant d&#39;établir une <em>chain of trust</em> (à\nl&#39;instar des bitcoins), permettant de rejouer l&#39;intégralité des modifications\napportées à la valeur. Cela permet de faire des bases de données\ndécentralisées, qui tournent individuellement sur les browsers de chacun,\ntouchant la même source de données, mais qui peuvent se réconcilier plus tard\ncar l&#39;ensemble des transactions est gardé en mémoire et peut être rejouée.</p>\n\n<p>Au final je dois bien avouer que j&#39;ai pas tout compris aux applications\nconcrètes de tout ça, mais ça donnait quand même envie !</p>\n\n<p>Pour finir, dans les questions-réponses dont je parlais il lui a été demandé\ncomment il faisait pour être aussi productif. Sa réponse est sans appel : </p>\n\n<blockquote>\n<p>Facile, je n&#39;ai pas de boulot. Si vous voulez commencer à être productif,\nquittez votre job.</p>\n</blockquote>\n\n<p>En vrac sur d&#39;autres questions, notamment sur npm :</p>\n\n<blockquote>\n<p>Npm c&#39;est un peu comme une décharge publique. Tout le monde y mets plein de\nchoses, des choses qui marchent, d&#39;autres qui marchent pas, et parfois, en\nfouillant bien on trouve des pépites. Comme dans tout langage, il faut une\nénorme quantité de mauvais code pour avoir du bon code. C&#39;est pour ça que les\nartistes qui font des chefs d&#39;œuvres vivent dans des taudis en bordel. Au final\nce n&#39;est pas une question de langage, de si on mets des parenthèses et des\npoints-virgules ou non, c&#39;est une histoire d&#39;écosystème de développeurs et de\ncommunauté.</p>\n</blockquote>\n\n<p>Vraiment, un chouette type !</p>\n\n<h2>Charlie Robbins</h2>\n\n<p>Ensuite, <a href=\"https://twitter.com/indexzero\">Charlie Robbins</a>, de\n<a href=\"https://www.nodejitsu.com/\">Nodejitsu</a> nous\na parlé de npm aussi, mais d&#39;un point de vu statistique. Il a analysé les repos\nnpm pour faire de l&#39;analyse statistique dessus et savoir les modules les plus\nutilisés comme dépendances, les versions les plus stables (ie. utilisées par le\nplus de packages), celles qui présentent le plus de failles de sécurités, etc.</p>\n\n<p>Le gars est sans doute très fort pour faire des statistiques sur des données de\ntype graph (et ses slides sont très jolis), mais concrétement je n&#39;ai rien tiré\nréellement de cette présentation.</p>\n\n<h2>Justin Meyer</h2>\n\n<p><a href=\"https://twitter.com/justinbmeyer\">Justin Meyer</a> nous a quand lui un peu\néloigné du code et s&#39;est rapproché des humains derrière les écrans. Il\na effectué lui aussi quelques stats, à plus petit échelle, sur les projets\nsur lesquels il a travaillé durant les dernières années. Il a ensuite noté\nchacun des projets selon des tas de critères (sortie dans les temps, effort de\ndev, nombre de bugs, etc) et pour chacun il a vérifié s&#39;ils possédaient\ntelle ou telle carac (test unitaire, module loader, documentation, user\ntesting, etc).</p>\n\n<p>Il a ensuite mis ces informations en regard pour en déduire les éléments qui\ninfluent le plus dans la réussite d&#39;un projet, afin de créer une checklist des\nchoses à faire pour s&#39;assurer un maximum de chances de réussites.</p>\n\n<p>L&#39;idée est très intéressante, mais comme son initiative vient <a href=\"https://github.com/bitovi/checklist\">à peine de\ncommencer</a>, il n&#39;avait pas vraiment de\nréels chiffres à sortir sur les éléments les plus influençants. Néanmoins, en\nprenant quelques pincettes avec les chiffres (calculés sur un petit\néchantillon), on arrive quand même à isoler les éléments suivants comme ayant\nété des facteurs clés du succès du projet : </p>\n\n<ul>\n<li>user testing</li>\n<li>design documentation</li>\n<li>shared vision and roadmap</li>\n<li>release in less than 6 months</li>\n<li>social events</li>\n</ul>\n\n<h2>Domenic Denicola</h2>\n\n<p><a href=\"https://twitter.com/domenic\">Domenic</a>, nous a ensuite parlé de\n<a href=\"https://github.com/tmpvar/jsdom\">JSDom</a>. Selon\nlui, le meilleur moyen d&#39;apprendre comment quelque chose fonctionne est de le\nrecoder... en Javascript. Lui et d&#39;autres ont donc recodé le principe du\nDocument Object Model en nodejs, de manière à pouvoir parser un arbre HTML (et\nle CSS/JS qui en découle) sans avoir besoin d&#39;un browser.</p>\n\n<p>Un peu dubitatif au démarrage quand à l&#39;utilité d&#39;un tel projet, je suis\nfinalement resté bluffé par le niveau de maturité de JSDom et je pense que je\nl&#39;utiliserai si le besoin s&#39;en fait sentir (pour éviter d&#39;utiliser tout une\nstack de browser quand juste le DOM est nécessaire).</p>\n\n<p>Ils réimplémentent complétement les API natives du DOM (<code>document</code>, <code>window</code>,\n<code>HTTPRequest</code>, etc). Le cas d&#39;usage le plus courant est pour faire du rendering\ncomplet coté serveur. On lui passe un input HTML, du JS et du CSS à coté, et on\npeut ensuite requêter le DOM pour obtenir les listeners, les styles, etc.</p>\n\n<p>Basé sur JSDom, il existe aussi <code>zombie.js</code> qui permet d&#39;aller un peu plus loin\npour simuler un navigateur. On peut par exemple simuler le\nremplissage de formulaire. Il semble que la bibliothèque soit pas mal utilisée\npour tricher sur les jeux en ligne.</p>\n\n<p>Afin d&#39;être au plus proche de la spec officielle du DOM, ils ont développé un\noutil qui accepte en input un fichier de spec au format <code>webidl</code>, et qui le\ntransforme en un fichier de classe JSDom en Javascript. Comme ça, il est\n(presque) inutile de comprendre la spec pour pouvoir l&#39;implémenter.</p>\n\n<h2>Angus Croll</h2>\n\n<p><a href=\"https://twitter.com/angustweets\">Angus Croll</a> nous a fait passer un très bon\nmoment avec un talk extrèmement intéressant intitulé &quot;Code &amp; Literature&quot;. Pour\nlui, Javascript est un langage très souple qui permet de faire énormément de\nchoses, et qui permet aussi de faire la même chose d&#39;énormément de façons\ndifférentes. Pour éviter de trop se disperser, on a inventé des best practices,\nqui fonctionnent dans la majorité des cas. Mais quand on rencontre un edge case\nimprévu qui va nous forcer à casser ces règles, on ne sait pas forcément\ncomment faire car on n&#39;a jamais appris qu&#39;une seule manière de faire.</p>\n\n<p>Lui nous incite à tester, à jouer avec le code, à essayer. Javascript nous\npermet de faire les choses de manière impérative, object ou fonctionnelle,\nprofitons-en. Ça ne suivra peut-être pas les guidelines et ne sera peut-être\npas propre selon les standards du projet, mais ça nous fera apprendre des\nchoses. Il n&#39;y a qu&#39;en essayant quelque chose d&#39;inconnu qu&#39;on peut apprendre.</p>\n\n<p>Lui aussi est d&#39;accord sur ce que disait Substack : il faut beaucoup de mauvais\ncode pour avoir du bon code. C&#39;est une phase d&#39;apprentissage obligatoire, et il\nne faut pas perdre de vue le coté fun de l&#39;apprentissage. Et les styleguides ne\nsont que des indications à un moment donné pour un projet donné, elles\névoluent dans le temps et dans l&#39;espace.</p>\n\n<p>Par exemple, on considérait avant les notations <code>if (!!x)</code>, <code>fn &amp;&amp; fn()</code> ou\n<code>(function(){...}())</code> comme étant des bad smell, alors qu&#39;aujourd&#39;hui on les\nconsidère comme des syntaxes tout à fait valides, pour peu qu&#39;on sache bien les\nutiliser. Le niveau des codeurs de JS a évolué, et ce qui était considéré comme\ndes syntaxes ésotériques fait aujourd&#39;hui partie intégrante du langage.</p>\n\n<p>Javascript est un langage à part entière, dont il faut comprendre les\nsubtilités. Au début on semble être en terrain connu, la syntaxe est facile,\nqu&#39;on vienne de Java ou de C, on s&#39;y retrouve. Puis on commence à plonger un\npeu plus et on se rends compte qu&#39;on n&#39;avait vu que la partie émergée de\nl&#39;iceberg et que tout le &quot;weird shit&quot; se trouve caché en dessous. Et tout\nà coup, tout semble compliqué. Alors on se barde de plein de bonnes pratiques\net de <code>jshint</code> et <code>jscs</code> et on se pense en sécurité. Mais on perds le fun.</p>\n\n<p>Playing is learning. C&#39;est en essayant de faire les choses différement qu&#39;on\napprends. Les développeurs autodidactes sont souvent les meilleurs, parce\nqu&#39;ils ont fait des erreurs, et comprennent ce que cela implique, ce qui\nfonctionne et ce qui ne fonctionne pas. Ils peuvent penser à des alternatives,\net continuent de s&#39;amuser.</p>\n\n<h2>Mike McNeil</h2>\n\n<p><a href=\"https://twitter.com/mikermcneil\">Mike McNeil</a>, créateur de\n<a href=\"http://sailsjs.org/#/\">SailsJS</a>, nous a parlé de machines. J&#39;ai pas pris\nénormément de notes sur cette conférence, donc je la fais essentiellement de\ntête.</p>\n\n<p>L&#39;idée des <a href=\"https://github.com/node-machine/machine\">machines</a> est de définir\nles méthodes de ses modules sous forme d&#39;objet, qui contiennent effectivement\ndans une clé la méthode en elle-même, mais surtout pas mal de metadata sur la\nméthode autour. On peut par exemple y ajouter des méthodes de <code>preinput</code> ou\n<code>postoutput</code> pour sanitizer le contenu ou le formatter d&#39;une certaine manière.\nOn peut aussi y définir les différents arguments, en indiquant des exemples, et\nune petite phrase de documentation.</p>\n\n<p>En faisant ainsi, on se rajoute une couche supérieure d&#39;abstraction au dessus\nde nos méthodes, mais on y gagne un moyen simple de faire de la documentation\nauto-générée et qui sera forcément à jour (pas comme des annotations sous forme\nde commentaire qui finissent toujours pas être désynchros).</p>\n\n<p>L&#39;idée parait intéressante, à condition que ces objets soient &quot;compilés&quot;\nfinalement en JS (et hop, encore un preprocesseur de plus dans le pipe).</p>\n\n<h2>John-David Dalton</h2>\n\n<p><a href=\"https://twitter.com/jdalton\">John-David Dalton</a>, créateur de\n<a href=\"https://lodash.com/\">lodash</a>, nous a parlé des shims et des bibliothèques et\npourquoi une bibliothèque est supérieure.</p>\n\n<p>Il commence par balayer tout un tas d&#39;a-priori qu&#39;on peut avoir sur les\nimplémentations natives dans les browsers. Comme quoi la syntaxe est plus\nsimple, que les perfs sont meilleures, qu&#39;il n&#39;y a pas besoin de compilation\nspéciale ou que les implémentations sont stables. Tout ceci n&#39;est pas vrai et\nil donne quelques exemples sur plusieurs browsers.</p>\n\n<p>Ensuite, il s&#39;attaque aux shims (qui consistent à définir manuellement des\nméthodes pour combler les trous des browsers, mais de laisser l&#39;implémentation\nnative si elle existe). Les shims sont une bonne solution, mais qui n&#39;est pas\nparfaite selon lui. Notamment, on subit les régressions de performance qui\npeuvent apparaitre entre les versions des navigateurs. Mais surtout, on risque\nde casser des implémentations si on remplace un prototype natif par notre\npropre version, lors des futures versions où ce prototype sera implémenté.</p>\n\n<p>Pour lui, la meilleure solution est d&#39;utiliser une bibliothèque, qui elle\ns&#39;assure d&#39;être compatible entre tous les navigateurs. Lodash implémente la\nmême API qu&#39;<a href=\"http://underscorejs.org/\">underscore</a>, mais avec un axe\nparticulier sur la performance. Pour avoir regardé le code source des deux\nlibrairies, celui d&#39;underscore est parfaitement lisible et clair et on aurait\ntous pu l&#39;écrire. Celui de lodash est bien plus complexe car même s&#39;il expose\nla même API les rouages internes passent par des optimisations bien plus\nimportantes.</p>\n\n<p>En plus de ça, lodash offre du sucre syntaxique pour les appels les plus\ncourants des méthodes et permet de chainer et de fusionner les itérations\n<code>map</code>, <code>filter</code> et <code>take</code>. Si vous souhaitez par exemple prendre les 10\npremiers éléments de votre liste qui matchent tel critère après être passé par\ntelle transformation alors lodash s&#39;arretera dès qu&#39;il aura trouvé les 10\nélements. Avec underscore ou une autre implémentation classique, on aurait du\nitérer trois fois sur le même set (une pour la transfo, une pour le filter et\nune pour n&#39;en prendre que 10).</p>\n\n<h2>Soledad Penades</h2>\n\n<p>Démos de web audio, en jouant sur les pitchs et la fréquence. J&#39;avoue que j&#39;ai\npas énormément de souvenirs de cette présentation.</p>\n\n<h2>Joe McCann</h2>\n\n<p><a href=\"https://twitter.com/joemccann\">Joe McCann</a> nous parle d&#39;optimisations de V8,\nle moteur qui fait tourner node.  Pour lui, il y a deux types d&#39;ingénieurs;\nceux qui se demandent &quot;comment ça marche ?&quot; et ceux qui se demandent &quot;qu&#39;est-ce\nque je peux construire avec ça ?&quot;. Lui se situe dans la première catégorie et\na plongé dans les rouages de V8 pour nous remonter quelques astuces d&#39;optim de\nperf.</p>\n\n<p>V8 est extremement intelligent et va s&#39;occuper de faire la majorité des\noptimisations tout seul. Néanmoins, il y a moyen de l&#39;aider en le mettant sur\nla bonne piste.</p>\n\n<p>Déjà, définir des fonctions qui acceptent toujours le même nombre d&#39;arguments,\net toujours de même type va lui permettre d&#39;optimiser la mémoire allouée. Quand\non défini des objets, il est plus intéressants de définir l&#39;objet, avec toutes\nses clés (même <code>null</code> ou <code>undefined</code>) plutot que de définir un objet vide et\nd&#39;ajouter ensuite les clés à la main. Ensuite, il faut favoriser les tableaux\nd&#39;élements de même type (éviter de mixer des int, string et objets par\nexemple), ce qui parait assez évident. Dans le même ordre d&#39;idée, V8 parvient\nplus facilement à optimiser les fonctions nommées que les fonctions anonymes,\nmême si elles sont directement invoquées.</p>\n\n<p>Mais surtout, là où l&#39;optimisation devient plus obscure c&#39;est sur la taille (en\ncaractères) d&#39;une fonction. En effet, par défaut, si une méthode fait moins de\n600 caractères (commentaires inclus) V8 va la garder en mémoire directement\nplutot que d&#39;avoir un pointeur vers sa définition. Joe nous a fait quelques\ndémos en grossissant artificiellement la taille d&#39;une méthode en ajoutant\nsimplement des commentaires et en la jouant des millions de fois. La différence\nentre les deux était flagrante (de 1 à 10s).</p>\n\n<p>Cette limite de 600 chars est paramétrable en passant un flag à V8\nà l&#39;initialisation (<code>--max_inlined_source_size</code>). Et il est aussi possible de\nchanger cette limite on the fly directement dans une appli node (par exemple\nsur une route donnée), en utilisant la syntaxe (étrange) <code>%SetFlags()</code> qui\npermet de passer l&#39;instruction directement à la couche C depuis le js.</p>\n\n<h2>Paul O&#39;Shannessy</h2>\n\n<p><a href=\"https://twitter.com/zpao\">Paul</a> nous a parlé de\n<a href=\"http://facebook.github.io/react/\">React</a>. React est le V du trigramme MVC et\nvient de chez Facebook. Initialement, il s&#39;appellait XHP, un enfant illégitime\nentre PHP et XML.</p>\n\n<p>Le principe de React est d&#39;avoir des composants d&#39;UI réutilisables et qui sont\nuniquement responsables de l&#39;affichage de leur data. La donnée arrive forcément\nd&#39;en haut. Le composant recoit sa nouvelle donnée, mets à jour son affichage.</p>\n\n<p>Honnêtement, plus j&#39;entends parler de React et plus j&#39;ai envie d&#39;essayer. Ça me\nsemble une manière tellement élégante d&#39;isoler ses composants UI tout en leur\ngardant une logique simple. Le composant n&#39;est pas responsable de la donnée, ce\nn&#39;est pas lui qui en garde une copie, il est juste notifié de son changement et\nse doit de se mettre à jour en fonction.</p>\n\n<p>Mon résumé de React ne lui fait hommage, mais on mettra ça sur le compte de la\nfatigue à la fin de l&#39;écriture de ce CR.</p>\n\n<h2>Julien Lecompte et Yehuda Katz</h2>\n\n<p>Je n&#39;ai pas parlé des interventions de <a href=\"https://twitter.com/powersander\">Julien\nLecompte</a> et <a href=\"https://twitter.com/wycats\">Yehuda\nKatz</a> car je n&#39;ai pas pris de notes à ce moment\n(fatigue, manque de batterie de laptop ? je ne me souviens plus de la raison).</p>\n\n<p>Julien nous a parlé du YUI framework, de son histoire et de ce qu&#39;il est\ndevenu. Yehuda nous a parlé de la difficulté de maintenir des projets\nopen-source et de les faire monter de version majeure sans s&#39;aliéner toute la\ncommunauté (transparence, rétro-compatibilité, eat your own dogfood,\nopen-source rapidement). Même s&#39;il ne l&#39;a pas nommé, tout ce qu&#39;il indiquait\nétait l&#39;exact opposé de ce qu&#39;Angular est en train de faire pour sa v2.</p>\n\n<h2>Conclusion</h2>\n\n<p>Beaucoup de sujets ont été abordés durant cette journée, sans qu&#39;il ne soit\npossible de donner une ligne claire. Autant\nà <a href=\"http://www.dotscale.io/\">dotScale</a> il était évident que le gros sujet était\n<a href=\"https://www.docker.com/\">Docker</a> tellement toutes les présentations en\nparlaient, autant là tout le monde parlait de choses différentes : du backend,\ndu frontend, des browsers, des serveurs, des outils de builds, des processus,\netc.</p>\n\n<p>Je retiendrai particulièrement les interventions de Substack et Angus Croll\ncomme étant les deux moments forts de la journée. Je noterai cependant la\ntotale absence d&#39;Angular dans cet événement. Seul Yehuda en a parlé sans le\nciter, comme quoi, Angular et Javascript restent deux mondes différents.</p>\n",
  "markdown": "Le 19 Novembre 2014, au [Théatre de Paris](http://www.theatredeparis.com/),\r\navait lieu la nouvelle édition de [dotJS](http://www.dotjs.eu/). Un lieu\r\nmagnifique, des speakers de renom et des présentations intéressantes. Je n'ai\r\npas réussi à sortir un fil directeur général au programme, mais voici un petit\r\nrésumé des différentes conférences.\r\n\r\nC'est dans l'ordre chronologique de la journée, mais sans doute un peu en vrac\r\ndans les idées.\r\n\r\n## James Halliday aka Substack\r\n\r\n<iframe 
class="youtube-player"
type="text/html" 
width="640" 
height="390"
src="http://www.youtube.com/embed/J9_VaU4N3Rg"
frameborder="0"
allowfullscreen
></iframe>\r\n\r\n[Substack](https://twitter.com/substack), le mec qui code même dans son sommeil\r\n(jetez un œil à [sa timeline](https://github.com/substack)), nous a parlé de...\r\nplein de choses. Je suis pas sur de pouvoir en ressortir le propos exact, mais\r\nj'ai beaucoup apprécié le personnage et la session de questions-réponses qui\r\na suivi son intervention.\r\n\r\nIl a commencé à nous parler de comment réussir à avoir une\r\napplication web qui puisse fonctionner complétement offline, avec le mode\r\nonline qui soit simplement un bonus. Pour ça, on passe par un cache manifest,\r\nqui définit la liste des éléments qui doivent être gardés pour le mode offline.\r\nEt si on veut aller encore plus loin, on mets carrément le cache manifest dans\r\nle cache manifest, comme ça on est sur que notre appli ne se connectera pas.\r\n\r\nIl a ensuite énoncé quelque chose de très vrai : un site offline est le\r\nmeilleur moyen d'avoir un scaling infini. Zero requête vers le serveur, pas de\r\nproblème de charge, il peut y avoir une infinité de personnes qui utilisent le\r\nsite en même temps, cela n'influera en rien sur ses fonctionnalités.\r\n\r\nIl a développé, comme à son habitude, un ensemble de modules pour aller dans\r\ncette direction. L'un d'eux utilise `localStorage` pour garder un historique des\r\nanciennes versions du site directement dans le browser. Il est ainsi possible\r\nde revenir à des versions de la veille ou de la semaine dernière à partir du\r\nmoment où on les a déjà téléchargé une fois.\r\n\r\nS'en vient ensuite la question de l'authentication quand on n'a pas de serveur\r\ndistant ? En utilisant les méthodes de crypto définies dans `crypto.subtle`, on\r\npeut réussir à faire une grosse partie de l'authent directement dans le\r\nbrowser.\r\n\r\nIl a finalement parlé d'un autre de ses modules,\r\n[forkdb](https://github.com/substack/forkdb), qui semble\r\nfonctionner comme un database key/value, mais où chaque value contient un hash\r\ndes metadata de son historique, permettant d'établir une _chain of trust_ (à\r\nl'instar des bitcoins), permettant de rejouer l'intégralité des modifications\r\napportées à la valeur. Cela permet de faire des bases de données\r\ndécentralisées, qui tournent individuellement sur les browsers de chacun,\r\ntouchant la même source de données, mais qui peuvent se réconcilier plus tard\r\ncar l'ensemble des transactions est gardé en mémoire et peut être rejouée.\r\n\r\nAu final je dois bien avouer que j'ai pas tout compris aux applications\r\nconcrètes de tout ça, mais ça donnait quand même envie !\r\n\r\nPour finir, dans les questions-réponses dont je parlais il lui a été demandé\r\ncomment il faisait pour être aussi productif. Sa réponse est sans appel : \r\n\r\n> Facile, je n'ai pas de boulot. Si vous voulez commencer à être productif,\r\nquittez votre job.\r\n\r\nEn vrac sur d'autres questions, notamment sur npm :\r\n\r\n> Npm c'est un peu comme une décharge publique. Tout le monde y mets plein de\r\n> choses, des choses qui marchent, d'autres qui marchent pas, et parfois, en\r\n> fouillant bien on trouve des pépites. Comme dans tout langage, il faut une\r\n> énorme quantité de mauvais code pour avoir du bon code. C'est pour ça que les\r\n> artistes qui font des chefs d'œuvres vivent dans des taudis en bordel. Au final\r\n> ce n'est pas une question de langage, de si on mets des parenthèses et des\r\n> points-virgules ou non, c'est une histoire d'écosystème de développeurs et de\r\n> communauté.\r\n\r\nVraiment, un chouette type !\r\n\r\n## Charlie Robbins\r\n\r\nEnsuite, [Charlie Robbins](https://twitter.com/indexzero), de\r\n[Nodejitsu](https://www.nodejitsu.com/) nous\r\na parlé de npm aussi, mais d'un point de vu statistique. Il a analysé les repos\r\nnpm pour faire de l'analyse statistique dessus et savoir les modules les plus\r\nutilisés comme dépendances, les versions les plus stables (ie. utilisées par le\r\nplus de packages), celles qui présentent le plus de failles de sécurités, etc.\r\n\r\nLe gars est sans doute très fort pour faire des statistiques sur des données de\r\ntype graph (et ses slides sont très jolis), mais concrétement je n'ai rien tiré\r\nréellement de cette présentation.\r\n\r\n## Justin Meyer\r\n\r\n[Justin Meyer](https://twitter.com/justinbmeyer) nous a quand lui un peu\r\néloigné du code et s'est rapproché des humains derrière les écrans. Il\r\na effectué lui aussi quelques stats, à plus petit échelle, sur les projets\r\nsur lesquels il a travaillé durant les dernières années. Il a ensuite noté\r\nchacun des projets selon des tas de critères (sortie dans les temps, effort de\r\ndev, nombre de bugs, etc) et pour chacun il a vérifié s'ils possédaient\r\ntelle ou telle carac (test unitaire, module loader, documentation, user\r\ntesting, etc).\r\n\r\nIl a ensuite mis ces informations en regard pour en déduire les éléments qui\r\ninfluent le plus dans la réussite d'un projet, afin de créer une checklist des\r\nchoses à faire pour s'assurer un maximum de chances de réussites.\r\n\r\nL'idée est très intéressante, mais comme son initiative vient [à peine de\r\ncommencer](https://github.com/bitovi/checklist), il n'avait pas vraiment de\r\nréels chiffres à sortir sur les éléments les plus influençants. Néanmoins, en\r\nprenant quelques pincettes avec les chiffres (calculés sur un petit\r\néchantillon), on arrive quand même à isoler les éléments suivants comme ayant\r\nété des facteurs clés du succès du projet : \r\n\r\n- user testing\r\n- design documentation\r\n- shared vision and roadmap\r\n- release in less than 6 months\r\n- social events\r\n\r\n\r\n## Domenic Denicola\r\n\r\n[Domenic](https://twitter.com/domenic), nous a ensuite parlé de\r\n[JSDom](https://github.com/tmpvar/jsdom). Selon\r\nlui, le meilleur moyen d'apprendre comment quelque chose fonctionne est de le\r\nrecoder... en Javascript. Lui et d'autres ont donc recodé le principe du\r\nDocument Object Model en nodejs, de manière à pouvoir parser un arbre HTML (et\r\nle CSS/JS qui en découle) sans avoir besoin d'un browser.\r\n\r\nUn peu dubitatif au démarrage quand à l'utilité d'un tel projet, je suis\r\nfinalement resté bluffé par le niveau de maturité de JSDom et je pense que je\r\nl'utiliserai si le besoin s'en fait sentir (pour éviter d'utiliser tout une\r\nstack de browser quand juste le DOM est nécessaire).\r\n\r\nIls réimplémentent complétement les API natives du DOM (`document`, `window`,\r\n`HTTPRequest`, etc). Le cas d'usage le plus courant est pour faire du rendering\r\ncomplet coté serveur. On lui passe un input HTML, du JS et du CSS à coté, et on\r\npeut ensuite requêter le DOM pour obtenir les listeners, les styles, etc.\r\n\r\nBasé sur JSDom, il existe aussi `zombie.js` qui permet d'aller un peu plus loin\r\npour simuler un navigateur. On peut par exemple simuler le\r\nremplissage de formulaire. Il semble que la bibliothèque soit pas mal utilisée\r\npour tricher sur les jeux en ligne.\r\n\r\nAfin d'être au plus proche de la spec officielle du DOM, ils ont développé un\r\noutil qui accepte en input un fichier de spec au format `webidl`, et qui le\r\ntransforme en un fichier de classe JSDom en Javascript. Comme ça, il est\r\n(presque) inutile de comprendre la spec pour pouvoir l'implémenter.\r\n\r\n## Angus Croll\r\n\r\n[Angus Croll](https://twitter.com/angustweets) nous a fait passer un très bon\r\nmoment avec un talk extrèmement intéressant intitulé \"Code & Literature\". Pour\r\nlui, Javascript est un langage très souple qui permet de faire énormément de\r\nchoses, et qui permet aussi de faire la même chose d'énormément de façons\r\ndifférentes. Pour éviter de trop se disperser, on a inventé des best practices,\r\nqui fonctionnent dans la majorité des cas. Mais quand on rencontre un edge case\r\nimprévu qui va nous forcer à casser ces règles, on ne sait pas forcément\r\ncomment faire car on n'a jamais appris qu'une seule manière de faire.\r\n\r\nLui nous incite à tester, à jouer avec le code, à essayer. Javascript nous\r\npermet de faire les choses de manière impérative, object ou fonctionnelle,\r\nprofitons-en. Ça ne suivra peut-être pas les guidelines et ne sera peut-être\r\npas propre selon les standards du projet, mais ça nous fera apprendre des\r\nchoses. Il n'y a qu'en essayant quelque chose d'inconnu qu'on peut apprendre.\r\n\r\n\r\nLui aussi est d'accord sur ce que disait Substack : il faut beaucoup de mauvais\r\ncode pour avoir du bon code. C'est une phase d'apprentissage obligatoire, et il\r\nne faut pas perdre de vue le coté fun de l'apprentissage. Et les styleguides ne\r\nsont que des indications à un moment donné pour un projet donné, elles\r\névoluent dans le temps et dans l'espace.\r\n\r\nPar exemple, on considérait avant les notations `if (!!x)`, `fn && fn()` ou\r\n`(function(){...}())` comme étant des bad smell, alors qu'aujourd'hui on les\r\nconsidère comme des syntaxes tout à fait valides, pour peu qu'on sache bien les\r\nutiliser. Le niveau des codeurs de JS a évolué, et ce qui était considéré comme\r\ndes syntaxes ésotériques fait aujourd'hui partie intégrante du langage.\r\n\r\nJavascript est un langage à part entière, dont il faut comprendre les\r\nsubtilités. Au début on semble être en terrain connu, la syntaxe est facile,\r\nqu'on vienne de Java ou de C, on s'y retrouve. Puis on commence à plonger un\r\npeu plus et on se rends compte qu'on n'avait vu que la partie émergée de\r\nl'iceberg et que tout le \"weird shit\" se trouve caché en dessous. Et tout\r\nà coup, tout semble compliqué. Alors on se barde de plein de bonnes pratiques\r\net de `jshint` et `jscs` et on se pense en sécurité. Mais on perds le fun.\r\n\r\nPlaying is learning. C'est en essayant de faire les choses différement qu'on\r\napprends. Les développeurs autodidactes sont souvent les meilleurs, parce\r\nqu'ils ont fait des erreurs, et comprennent ce que cela implique, ce qui\r\nfonctionne et ce qui ne fonctionne pas. Ils peuvent penser à des alternatives,\r\net continuent de s'amuser.\r\n\r\n## Mike McNeil\r\n\r\n[Mike McNeil](https://twitter.com/mikermcneil), créateur de\r\n[SailsJS](http://sailsjs.org/#/), nous a parlé de machines. J'ai pas pris\r\nénormément de notes sur cette conférence, donc je la fais essentiellement de\r\ntête.\r\n\r\nL'idée des [machines](https://github.com/node-machine/machine) est de définir\r\nles méthodes de ses modules sous forme d'objet, qui contiennent effectivement\r\ndans une clé la méthode en elle-même, mais surtout pas mal de metadata sur la\r\nméthode autour. On peut par exemple y ajouter des méthodes de `preinput` ou\r\n`postoutput` pour sanitizer le contenu ou le formatter d'une certaine manière.\r\nOn peut aussi y définir les différents arguments, en indiquant des exemples, et\r\nune petite phrase de documentation.\r\n\r\nEn faisant ainsi, on se rajoute une couche supérieure d'abstraction au dessus\r\nde nos méthodes, mais on y gagne un moyen simple de faire de la documentation\r\nauto-générée et qui sera forcément à jour (pas comme des annotations sous forme\r\nde commentaire qui finissent toujours pas être désynchros).\r\n\r\nL'idée parait intéressante, à condition que ces objets soient \"compilés\"\r\nfinalement en JS (et hop, encore un preprocesseur de plus dans le pipe).\r\n\r\n## John-David Dalton\r\n\r\n[John-David Dalton](https://twitter.com/jdalton), créateur de\r\n[lodash](https://lodash.com/), nous a parlé des shims et des bibliothèques et\r\npourquoi une bibliothèque est supérieure.\r\n\r\nIl commence par balayer tout un tas d'a-priori qu'on peut avoir sur les\r\nimplémentations natives dans les browsers. Comme quoi la syntaxe est plus\r\nsimple, que les perfs sont meilleures, qu'il n'y a pas besoin de compilation\r\nspéciale ou que les implémentations sont stables. Tout ceci n'est pas vrai et\r\nil donne quelques exemples sur plusieurs browsers.\r\n\r\nEnsuite, il s'attaque aux shims (qui consistent à définir manuellement des\r\nméthodes pour combler les trous des browsers, mais de laisser l'implémentation\r\nnative si elle existe). Les shims sont une bonne solution, mais qui n'est pas\r\nparfaite selon lui. Notamment, on subit les régressions de performance qui\r\npeuvent apparaitre entre les versions des navigateurs. Mais surtout, on risque\r\nde casser des implémentations si on remplace un prototype natif par notre\r\npropre version, lors des futures versions où ce prototype sera implémenté.\r\n\r\nPour lui, la meilleure solution est d'utiliser une bibliothèque, qui elle\r\ns'assure d'être compatible entre tous les navigateurs. Lodash implémente la\r\nmême API qu'[underscore](http://underscorejs.org/), mais avec un axe\r\nparticulier sur la performance. Pour avoir regardé le code source des deux\r\nlibrairies, celui d'underscore est parfaitement lisible et clair et on aurait\r\ntous pu l'écrire. Celui de lodash est bien plus complexe car même s'il expose\r\nla même API les rouages internes passent par des optimisations bien plus\r\nimportantes.\r\n\r\nEn plus de ça, lodash offre du sucre syntaxique pour les appels les plus\r\ncourants des méthodes et permet de chainer et de fusionner les itérations\r\n`map`, `filter` et `take`. Si vous souhaitez par exemple prendre les 10\r\npremiers éléments de votre liste qui matchent tel critère après être passé par\r\ntelle transformation alors lodash s'arretera dès qu'il aura trouvé les 10\r\nélements. Avec underscore ou une autre implémentation classique, on aurait du\r\nitérer trois fois sur le même set (une pour la transfo, une pour le filter et\r\nune pour n'en prendre que 10).\r\n\r\n## Soledad Penades\r\n\r\nDémos de web audio, en jouant sur les pitchs et la fréquence. J'avoue que j'ai\r\npas énormément de souvenirs de cette présentation.\r\n\r\n## Joe McCann\r\n\r\n[Joe McCann](https://twitter.com/joemccann) nous parle d'optimisations de V8,\r\nle moteur qui fait tourner node.  Pour lui, il y a deux types d'ingénieurs;\r\nceux qui se demandent \"comment ça marche ?\" et ceux qui se demandent \"qu'est-ce\r\nque je peux construire avec ça ?\". Lui se situe dans la première catégorie et\r\na plongé dans les rouages de V8 pour nous remonter quelques astuces d'optim de\r\nperf.\r\n\r\nV8 est extremement intelligent et va s'occuper de faire la majorité des\r\noptimisations tout seul. Néanmoins, il y a moyen de l'aider en le mettant sur\r\nla bonne piste.\r\n\r\nDéjà, définir des fonctions qui acceptent toujours le même nombre d'arguments,\r\net toujours de même type va lui permettre d'optimiser la mémoire allouée. Quand\r\non défini des objets, il est plus intéressants de définir l'objet, avec toutes\r\nses clés (même `null` ou `undefined`) plutot que de définir un objet vide et\r\nd'ajouter ensuite les clés à la main. Ensuite, il faut favoriser les tableaux\r\nd'élements de même type (éviter de mixer des int, string et objets par\r\nexemple), ce qui parait assez évident. Dans le même ordre d'idée, V8 parvient\r\nplus facilement à optimiser les fonctions nommées que les fonctions anonymes,\r\nmême si elles sont directement invoquées.\r\n\r\nMais surtout, là où l'optimisation devient plus obscure c'est sur la taille (en\r\ncaractères) d'une fonction. En effet, par défaut, si une méthode fait moins de\r\n600 caractères (commentaires inclus) V8 va la garder en mémoire directement\r\nplutot que d'avoir un pointeur vers sa définition. Joe nous a fait quelques\r\ndémos en grossissant artificiellement la taille d'une méthode en ajoutant\r\nsimplement des commentaires et en la jouant des millions de fois. La différence\r\nentre les deux était flagrante (de 1 à 10s).\r\n\r\nCette limite de 600 chars est paramétrable en passant un flag à V8\r\nà l'initialisation (`--max_inlined_source_size`). Et il est aussi possible de\r\nchanger cette limite on the fly directement dans une appli node (par exemple\r\nsur une route donnée), en utilisant la syntaxe (étrange) `%SetFlags()` qui\r\npermet de passer l'instruction directement à la couche C depuis le js.\r\n\r\n## Paul O'Shannessy\r\n\r\n[Paul](https://twitter.com/zpao) nous a parlé de\r\n[React](http://facebook.github.io/react/). React est le V du trigramme MVC et\r\nvient de chez Facebook. Initialement, il s'appellait XHP, un enfant illégitime\r\nentre PHP et XML.\r\n\r\nLe principe de React est d'avoir des composants d'UI réutilisables et qui sont\r\nuniquement responsables de l'affichage de leur data. La donnée arrive forcément\r\nd'en haut. Le composant recoit sa nouvelle donnée, mets à jour son affichage.\r\n\r\nHonnêtement, plus j'entends parler de React et plus j'ai envie d'essayer. Ça me\r\nsemble une manière tellement élégante d'isoler ses composants UI tout en leur\r\ngardant une logique simple. Le composant n'est pas responsable de la donnée, ce\r\nn'est pas lui qui en garde une copie, il est juste notifié de son changement et\r\nse doit de se mettre à jour en fonction.\r\n\r\nMon résumé de React ne lui fait hommage, mais on mettra ça sur le compte de la\r\nfatigue à la fin de l'écriture de ce CR.\r\n\r\n## Julien Lecompte et Yehuda Katz\r\n\r\nJe n'ai pas parlé des interventions de [Julien\r\nLecompte](https://twitter.com/powersander) et [Yehuda\r\nKatz](https://twitter.com/wycats) car je n'ai pas pris de notes à ce moment\r\n(fatigue, manque de batterie de laptop ? je ne me souviens plus de la raison).\r\n\r\nJulien nous a parlé du YUI framework, de son histoire et de ce qu'il est\r\ndevenu. Yehuda nous a parlé de la difficulté de maintenir des projets\r\nopen-source et de les faire monter de version majeure sans s'aliéner toute la\r\ncommunauté (transparence, rétro-compatibilité, eat your own dogfood,\r\nopen-source rapidement). Même s'il ne l'a pas nommé, tout ce qu'il indiquait\r\nétait l'exact opposé de ce qu'Angular est en train de faire pour sa v2.\r\n\r\n## Conclusion\r\n\r\nBeaucoup de sujets ont été abordés durant cette journée, sans qu'il ne soit\r\npossible de donner une ligne claire. Autant\r\nà [dotScale](http://www.dotscale.io/) il était évident que le gros sujet était\r\n[Docker](https://www.docker.com/) tellement toutes les présentations en\r\nparlaient, autant là tout le monde parlait de choses différentes : du backend,\r\ndu frontend, des browsers, des serveurs, des outils de builds, des processus,\r\netc.\r\n\r\nJe retiendrai particulièrement les interventions de Substack et Angus Croll\r\ncomme étant les deux moments forts de la journée. Je noterai cependant la\r\ntotale absence d'Angular dans cet événement. Seul Yehuda en a parlé sans le\r\nciter, comme quoi, Angular et Javascript restent deux mondes différents.\r\n"
}