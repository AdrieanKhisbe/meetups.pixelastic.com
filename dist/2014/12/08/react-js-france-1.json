{
  "id": "/2014/12/08/react-js-france-1",
  "title": "React JS France #1",
  "url": "http://meetups.pixelastic.com//2014/12/08/react-js-france-1/",
  "tags": [
    "react"
  ],
  "date": 1417993200,
  "html": "<p>Premier meetup <a href=\"http://facebook.github.io/react/\">React</a>, organisé par <a href=\"http://www.deezer.com/\">Deezer</a> et <a href=\"http://www.altima-agency.com/fr\">Altima</a>, chez\nDeezer. Bon panel de speakers pour une première, avec <a href=\"https://twitter.com/bloodyowl\">Matthias\nLebrun</a> d&#39;Altima, <a href=\"https://twitter.com/yannickc\">Yannick Croissant</a> de Deezer et\n<a href=\"https://twitter.com/vjeux\">Christopher Chedeau</a> de React (Facebook).</p>\n\n<h2>React, où comment simplifier la conception d&#39;UI</h2>\n\n<p>On commence par Matthias qui nous fait une intro à React pour ceux qui ne\nconnaissent pas. Ça tombait bien, je ne connaissais pas et ça m&#39;a bien donné\nenvie d&#39;essayer.</p>\n\n<p>Le principe de React est de simplifier la conception des UI, où tout est devenu\ntrop compliqué au fil des années. On avait un simple serveur qui nous renvoyait\ndu HTML au début, maintenant on a des SPA qui vont chercher seulement leurs\ndonnées depuis le serveur et doivent mettre à jour leur markup en fonction.</p>\n\n<p>Avec React, tout est un composant. Chaque composant possède sa propre méthode\n<code>render</code> qui doit retourner un markup HTML qui sera inséré dans le DOM.\nL&#39;avantage d&#39;avoir une simple méthode comme ça pour chaque composant c&#39;est que\nc&#39;est facile à tester unitairement. Les composants sont simples, petits,\nisolés, et les méthodes sont donc faciles à tester.</p>\n\n<p>Le composant possède aussi un état, une liste de variables internes qu&#39;il peut\nmodifier en réponse à certaines actions de l&#39;utilisateur ou recevoir depuis un\nparent. Ces variables sont privées, et lui permettent de choisir les\nmodifications à appliquer au markup.</p>\n\n<p>Le moteur de template de React utilise une syntaxe <code>jsx</code>, qui est croisement\nentre du XML et du Javascript, ce qui fait un peu peur au premier abord. Mais\nc&#39;est juste du sucre syntaxique, React arrive avec son pre-processeur qui\ntransforme ce <code>jsx</code> dans nos fichiers js en du vrai js. Le pre-processeur\narrive avec quelques autres goodies d&#39;ES6, et sans doute aussi dans le futur\navec des annotations, du type checking, etc.</p>\n\n<p>Du coup, on a un vrai moteur de template, qui est tout simplement du js. On\npeut y faire des conditions, des boucles, du <code>map</code>, <code>reduce</code>, bref tout ce\nqu&#39;on veut faire en js sans devoir passer par une complexe syntaxe de template.\nIl est donc là inutile de réinventer de la logique dans un autre langage.</p>\n\n<p>React continue sur sa lancée de simplification en faisant en sorte que tout\nsoit explicite. Ici, pas d&#39;API polymorphe à la jQuery où les getters et les\nsetters se mélangent. On a même certaines fonctions qui sont déconseillées\n(comme ajouter directement un <code>innerHTML</code>), et qui possèdent donc des noms bien\nflagrants pour montrer qu&#39;on fait quelque chose de mal quand on les utilise\n(<code>dangerouslySetInnerHTML</code>).</p>\n\n<p>Pour revenir rapidement sur la méthode <code>render</code>, qui est le cœur de React, on\na aussi autour la méthode <code>shouldComponentUpdate</code>, qu&#39;on peut overrider pour\nindiquer au moteur que non, là, vraiment, c&#39;est pas la peine de faire un\nnouveau rendering du component, je sais qu&#39;il n&#39;a pas bougé. Dans le même ordre\nd&#39;idée, on a accès aux events <code>willMount</code>, <code>didMount</code> et <code>willUnmount</code> pour\nlancer du code custom à différents moment de la vie d&#39;un composant.</p>\n\n<p>React possède un très puissant algo de rendering, qui va checker le retour du\n<code>render</code> d&#39;un composant et de tout ses sous-composants pour savoir s&#39;il doit\nmettre à jour ou non son rendu. Il batche toutes les modifications ensemble\njusqu&#39;au prochain rendering du browser, et rajoute un petit algo de diff pour\nla route.</p>\n\n<p>Autre parti-pris, qui va dans le sens de la simplification, il n&#39;y a pas\nd&#39;héritage dans React, il n&#39;y a que de la composition à base de mixins. On\ndéfini des méthodes qu&#39;on pourra implanter dans différents composants, quels\nqu&#39;ils soient (comme réagir à un event de scroll ou de resize par exemple).</p>\n\n<p>React s&#39;abstrait du DOM officiel aussi en réimplementant pas mal de choses,\nmais en le faisant ainsi de manière cross-browser. Il réimplémente par exemple\nle principe d&#39;event capture et event bubbling, tout seul. Il en profite pour\nrajouter une petit optim de perf dans l&#39;histoire; plutot que de repasser une\nnouvelle instance de l&#39;objet event à chaque intermédiaire, il recycle toujours\nla même liste de <code>x</code> objets qu&#39;il passe à chacun des handlers.</p>\n\n<p>Idem, il possède sa propre représentation du DOM pour savoir quand faire des\nupdates, qu&#39;il appelle le virtual DOM (et je crois qu&#39;ils utilisent JSDOM, mais\npas sur).</p>\n\n<p>Globalement, j&#39;ai été convaincu par React et j&#39;ai bien envie d&#39;essayer sur un\nprochain projet ou side-project. La simplicité avec laquelle on peut gérer\nnotre affichage simplifie pas mal de chose. Le markup n&#39;est plus du tout source\nde la donnée, il se concentre juste sur afficher les choses d&#39;une manière ou\nd&#39;un autre quand elles changent. Les algos de diff, super simples\nà coomprendre, permettent de s&#39;assurer qu&#39;on ne render par les choses pour\nrien, et les exposer sous forme de méthodes testables rends le truc encore plus\nattractif.</p>\n\n<p>Je pense que ça s&#39;incruste facilement dans un projet Backbone, mais que ça doit\nêtre la bonne galère de le passer dans de l&#39;Angular.</p>\n\n<h2>Isomorphic JS</h2>\n\n<p>La seconde présentation, de Yannick Croissant, nous parlait de Javascript\nisomorphique, ou de comment générer la même application en front comme en back.\nBon, j&#39;avais déjà assisté à son atelier à ParisWeb sur le même sujet, du coup\nj&#39;ai surtout écouté d&#39;une oreille distraite et n&#39;ai pas pris de notes.</p>\n\n<p>Néanmoins, de mémoire il était question des problèmes que cause le fait de\npartir en mode SPA. </p>\n\n<p>Déjà on duplique de la logique de code entre le back et le front, ce qui est\nparticulièrement flagrant au niveau des validations de formulaires. On veut\nfournir une expérience riche, du coup on ne veut pas perdre du temps avec des\nappels serveurs pour vérifier la validité d&#39;un champ de formulaire, et on veut\nles tester rapidement en local, en y déportant des règles métiers. Mais on ne\npeut pas non plus l&#39;enlever du backend pour des raisons de sécurité. On se\nretrouve donc souvent à coder deux fois la même chose, des deux cotés. Au début\nde NodeJS on pensait que le fait d&#39;avoir le même langage des deux cotés allait\npermettre d&#39;éviter de coder deux fois les choses, mais le langage n&#39;a pas grand\nchose à voir là dedans, la question est plus générique au niveau de l&#39;archi.</p>\n\n<p>Avoir une appli SPA pose aussi de gros problèmes en terme de référencement.\nMême si Google comprends le JS, ou même si on peut faire des hacks à base de\nphantomJS pour générer des pages statiques à servir aux robots crawleurs, ça\nreste des pansements sur des jambes de bois. Le modèle n&#39;est pas adapté.</p>\n\n<p>React permet de solutionner ce problème de manière assez élégante. Le serveur\ngénère un HTML à servir au client, incluant du React, qu&#39;il peut lui même\ninstancier et modifier, comme s&#39;il tournait dans un browser. C&#39;est un état\ninitial qui est servi au client. Puis toutes les mises à jours suivantes sont\nsimplement de nouveaux retours de l&#39;API qui vont déclencher des mises à jour de\nla vue dans le client. Si on reload complétement la page, la nouvelle page\nrendue par le serveur retournera un nouvel état de départ, mais encore une fois\nles nouvelles modifs se feront sous forme de diff. On a là une approche\nincrémentale, qui permet des affichage de page plus rapides.</p>\n\n<p>On touche là au meilleur des deux mondes. Sur une url données, dans un contexte\ndonné, notre serveur nous donnera un HTML parfaitement formé, parfaitement\nadapté pour le crawling, le SEO, l&#39;accessibilité, etc. Si le navigateur est en\nmesure d&#39;executer React, il peut mettre à jour la vue de manière incrémentale\nen redemandant les nouvelles infos au backend, qui peut se permettre de la lui\nretourner de manière simple sous forme de data.</p>\n\n<h2>React, CSS in JS</h2>\n\n<p>Le dernier talk était de Chistophe Chedeau, de chez Facebook (et sans doute\nconnu de certains d&#39;entre vous pour son boulot sur Curse Gaming). Il nous\na présenté React depuis sa création jusqu&#39;à ce qu&#39;il est aujourd&#39;hui.</p>\n\n<p>L&#39;idée principale derrière Reacte était de simplifier la codebase de Facebook.\nDes milliers d&#39;ingénieurs qui bossent sur du front-end en même temps, avec des\ncompétences en HTML/CSS très variées. Il n&#39;y a pas vraiment de dev front chez\nFacebook, tous les devs travaillent sur toutes les parties, qu&#39;elles soient\nback ou front. Du coup, ils ont souhaité abstraire au maximum certaines parties\ndu markup pour limiter les erreurs, et simplifier le développement.</p>\n\n<p>Un des problèmes majeur de CSS qui se fait ressentir sur une codebase comme\ncelle-là, c&#39;est que tout dans CSS est globales. On definit une classe, elle va\ns&#39;appliquer partout dans le markup. Certes on peut préfixer un selecteur pour\nle rendre plus precis, mais on n&#39;est jamais sur à 100% d&#39;avoir une isolation\nparfaite. Un autre dev peux, consciemment ou non, overrider nos styles. En\nutilisant une méthode comme BEM, on peut limiter ce problème mais alors on\nrends le code extremement difficile à minifier, avec des classes à rallonge sur\npresque tous les éléments.</p>\n\n<p>Le second problème majeur est qu&#39;il est très difficile de supprimer du code. Il\nn&#39;y a pas de couverture de code comme dans d&#39;autres langages qui pourrait être\ndéduite par des tests unitaires. Quand on supprime du CSS, on ne sait jamais\nréellement ce qu&#39;on va casser.</p>\n\n<p>Et pour finir, ils souhaitaient un moyen simple de pouvoir partager des\nconstantes entre PHP, Javascript et CSS (un code couleur, un nombre d&#39;éléments\nà afficher, un flag de feature flipping, etc).</p>\n\n<p>Ils ont donc planché sur un moyen de créer des composants isolés, qui chargent\nleurs propres dépendances, qui ne se fassent pas overrider par l&#39;extérieur et\nqui ne puissent pas non plus le faire.</p>\n\n<p>Leur action principale, pour obtenir ce pouvoir, a été de convertir le CSS en\nJavascript. Tout simplement en React, ils n&#39;écrivent pas leurs propriétés de\nstyle dans du CSS mais dans des objets JSON (légérement améliorés avec quelques\nhelpers). Cette partie m&#39;a un peu fait peur, et a continué à me suprendre dans\nle reste de la présentation. Finalement, après en avoir discuté avec d&#39;autres\ndevs qui font déjà du React régulièrement, cette approche n&#39;est pas obligatoire\net est même rarement employée : on continue d&#39;utiliser des classes pour le\nstyle.</p>\n\n<p>Bref, ces propriétés JSON/CSS sont ensuite appliquées directement en <code>style=</code>\nsur les éléments du markup. L&#39;avantage de cette méthode barbare est qu&#39;on est\ncertain qu&#39;on ne pourra pas se faire overrider par d&#39;autres classes (<code>style</code>\na la prio la plus forte), et comme on ne déclare pas de classe, on ne va rien\noverrider à l&#39;extérieur non plus. C&#39;est assez malin.</p>\n\n<p>De plus, ils en profitent pour &quot;optimiser&quot; certaines règles au passage (si on\nne mets pas d&#39;unité, c&#39;est des px par défaut par exemple) ou comportement (un\n<code>display:none</code> en React va carrément supprimer le nœud du DOM).</p>\n\n<p>En fait, pas mal de comportements du DOM classique sont recodés en Javascript\nen React. Quand j&#39;ai vu les <code>onMouseEnter</code> / <code>onMouseLeave</code> pour recréer le\n<code>:hover</code> j&#39;étais assez dubitatif quand même. Le speaker annoncait que le fait\nd&#39;être particulièrement explicite de cette manière rendait le code plus simple\nà comprendre. Je suis pas vraiment convaincu à premier abord, mais pourquoi\npas. Par contre, là où je le rejoins c&#39;est que ça rends le code de rendu\nvraiment plus facile à style. On peut écrire des tests unitaires qui vont\npouvoir manuellement passer un élément en <code>:hover</code> et tester un comportement en\nallant regarder le contenu de l&#39;objet de style.</p>\n\n<p>Il a fini par nous expliquer deux-trois autres optimisation que le moteur de\nReact opère. Pour moi, ce n&#39;est rien de plus que ce que le moteur natif du\nbrowser execute, mais qu&#39;ils ont recodé à la main, et ce qui leur permet de\ns&#39;affranchir des différences d&#39;implémentations entre navigateurs. Je ne sais\npas trop quoi penser à ce sujet. Certes ça permet de simplifier le dev et\nd&#39;offrir la même expérience à tout le monde, mais ça fait réinventer la roue.</p>\n\n<p>Plus le talk avancait et plus les démonstrations allaient dans ce sens et j&#39;en\nsuis sorti en me demandant où ça allait exactement. Vjeux lui même annonçait\nque React était jeune, qu&#39;ils ne s&#39;attendaient pas à ce qu&#39;il prenne autant\nd&#39;ampleur en dehors de Facebook et qu&#39;ils expérimentent des choses, mais que\ntout ne sera peut-être pas bon à garder.</p>\n\n<h2>Conclusion</h2>\n\n<p>Premier avant-gout de React, j&#39;ai été assez séduit par la simplicité qui s&#39;en\ndégage. La dernière conférence m&#39;a laissé plutot dubitatif (comme à chaque\nfois qu&#39;on essaie de remplacer CSS par JS parce que <em>&quot;CSS c&#39;est trop\ncompliqué&quot;</em>).</p>\n",
  "markdown": "Premier meetup [React][], organisé par [Deezer][] et [Altima][], chez\r\nDeezer. Bon panel de speakers pour une première, avec [Matthias\r\nLebrun][bloodyowl] d'Altima, [Yannick Croissant][yannickcr] de Deezer et\r\n[Christopher Chedeau][vjeux] de React (Facebook).\r\n\r\n## React, où comment simplifier la conception d'UI\r\n\r\nOn commence par Matthias qui nous fait une intro à React pour ceux qui ne\r\nconnaissent pas. Ça tombait bien, je ne connaissais pas et ça m'a bien donné\r\nenvie d'essayer.\r\n\r\nLe principe de React est de simplifier la conception des UI, où tout est devenu\r\ntrop compliqué au fil des années. On avait un simple serveur qui nous renvoyait\r\ndu HTML au début, maintenant on a des SPA qui vont chercher seulement leurs\r\ndonnées depuis le serveur et doivent mettre à jour leur markup en fonction.\r\n\r\nAvec React, tout est un composant. Chaque composant possède sa propre méthode\r\n`render` qui doit retourner un markup HTML qui sera inséré dans le DOM.\r\nL'avantage d'avoir une simple méthode comme ça pour chaque composant c'est que\r\nc'est facile à tester unitairement. Les composants sont simples, petits,\r\nisolés, et les méthodes sont donc faciles à tester.\r\n\r\nLe composant possède aussi un état, une liste de variables internes qu'il peut\r\nmodifier en réponse à certaines actions de l'utilisateur ou recevoir depuis un\r\nparent. Ces variables sont privées, et lui permettent de choisir les\r\nmodifications à appliquer au markup.\r\n\r\nLe moteur de template de React utilise une syntaxe `jsx`, qui est croisement\r\nentre du XML et du Javascript, ce qui fait un peu peur au premier abord. Mais\r\nc'est juste du sucre syntaxique, React arrive avec son pre-processeur qui\r\ntransforme ce `jsx` dans nos fichiers js en du vrai js. Le pre-processeur\r\narrive avec quelques autres goodies d'ES6, et sans doute aussi dans le futur\r\navec des annotations, du type checking, etc.\r\n\r\nDu coup, on a un vrai moteur de template, qui est tout simplement du js. On\r\npeut y faire des conditions, des boucles, du `map`, `reduce`, bref tout ce\r\nqu'on veut faire en js sans devoir passer par une complexe syntaxe de template.\r\nIl est donc là inutile de réinventer de la logique dans un autre langage.\r\n\r\nReact continue sur sa lancée de simplification en faisant en sorte que tout\r\nsoit explicite. Ici, pas d'API polymorphe à la jQuery où les getters et les\r\nsetters se mélangent. On a même certaines fonctions qui sont déconseillées\r\n(comme ajouter directement un `innerHTML`), et qui possèdent donc des noms bien\r\nflagrants pour montrer qu'on fait quelque chose de mal quand on les utilise\r\n(`dangerouslySetInnerHTML`).\r\n\r\nPour revenir rapidement sur la méthode `render`, qui est le cœur de React, on\r\na aussi autour la méthode `shouldComponentUpdate`, qu'on peut overrider pour\r\nindiquer au moteur que non, là, vraiment, c'est pas la peine de faire un\r\nnouveau rendering du component, je sais qu'il n'a pas bougé. Dans le même ordre\r\nd'idée, on a accès aux events `willMount`, `didMount` et `willUnmount` pour\r\nlancer du code custom à différents moment de la vie d'un composant.\r\n\r\nReact possède un très puissant algo de rendering, qui va checker le retour du\r\n`render` d'un composant et de tout ses sous-composants pour savoir s'il doit\r\nmettre à jour ou non son rendu. Il batche toutes les modifications ensemble\r\njusqu'au prochain rendering du browser, et rajoute un petit algo de diff pour\r\nla route.\r\n\r\nAutre parti-pris, qui va dans le sens de la simplification, il n'y a pas\r\nd'héritage dans React, il n'y a que de la composition à base de mixins. On\r\ndéfini des méthodes qu'on pourra implanter dans différents composants, quels\r\nqu'ils soient (comme réagir à un event de scroll ou de resize par exemple).\r\n\r\nReact s'abstrait du DOM officiel aussi en réimplementant pas mal de choses,\r\nmais en le faisant ainsi de manière cross-browser. Il réimplémente par exemple\r\nle principe d'event capture et event bubbling, tout seul. Il en profite pour\r\nrajouter une petit optim de perf dans l'histoire; plutot que de repasser une\r\nnouvelle instance de l'objet event à chaque intermédiaire, il recycle toujours\r\nla même liste de `x` objets qu'il passe à chacun des handlers.\r\n\r\nIdem, il possède sa propre représentation du DOM pour savoir quand faire des\r\nupdates, qu'il appelle le virtual DOM (et je crois qu'ils utilisent JSDOM, mais\r\npas sur).\r\n\r\nGlobalement, j'ai été convaincu par React et j'ai bien envie d'essayer sur un\r\nprochain projet ou side-project. La simplicité avec laquelle on peut gérer\r\nnotre affichage simplifie pas mal de chose. Le markup n'est plus du tout source\r\nde la donnée, il se concentre juste sur afficher les choses d'une manière ou\r\nd'un autre quand elles changent. Les algos de diff, super simples\r\nà coomprendre, permettent de s'assurer qu'on ne render par les choses pour\r\nrien, et les exposer sous forme de méthodes testables rends le truc encore plus\r\nattractif.\r\n\r\nJe pense que ça s'incruste facilement dans un projet Backbone, mais que ça doit\r\nêtre la bonne galère de le passer dans de l'Angular.\r\n\r\n## Isomorphic JS\r\n\r\nLa seconde présentation, de Yannick Croissant, nous parlait de Javascript\r\nisomorphique, ou de comment générer la même application en front comme en back.\r\nBon, j'avais déjà assisté à son atelier à ParisWeb sur le même sujet, du coup\r\nj'ai surtout écouté d'une oreille distraite et n'ai pas pris de notes.\r\n\r\nNéanmoins, de mémoire il était question des problèmes que cause le fait de\r\npartir en mode SPA. \r\n\r\nDéjà on duplique de la logique de code entre le back et le front, ce qui est\r\nparticulièrement flagrant au niveau des validations de formulaires. On veut\r\nfournir une expérience riche, du coup on ne veut pas perdre du temps avec des\r\nappels serveurs pour vérifier la validité d'un champ de formulaire, et on veut\r\nles tester rapidement en local, en y déportant des règles métiers. Mais on ne\r\npeut pas non plus l'enlever du backend pour des raisons de sécurité. On se\r\nretrouve donc souvent à coder deux fois la même chose, des deux cotés. Au début\r\nde NodeJS on pensait que le fait d'avoir le même langage des deux cotés allait\r\npermettre d'éviter de coder deux fois les choses, mais le langage n'a pas grand\r\nchose à voir là dedans, la question est plus générique au niveau de l'archi.\r\n\r\nAvoir une appli SPA pose aussi de gros problèmes en terme de référencement.\r\nMême si Google comprends le JS, ou même si on peut faire des hacks à base de\r\nphantomJS pour générer des pages statiques à servir aux robots crawleurs, ça\r\nreste des pansements sur des jambes de bois. Le modèle n'est pas adapté.\r\n\r\nReact permet de solutionner ce problème de manière assez élégante. Le serveur\r\ngénère un HTML à servir au client, incluant du React, qu'il peut lui même\r\ninstancier et modifier, comme s'il tournait dans un browser. C'est un état\r\ninitial qui est servi au client. Puis toutes les mises à jours suivantes sont\r\nsimplement de nouveaux retours de l'API qui vont déclencher des mises à jour de\r\nla vue dans le client. Si on reload complétement la page, la nouvelle page\r\nrendue par le serveur retournera un nouvel état de départ, mais encore une fois\r\nles nouvelles modifs se feront sous forme de diff. On a là une approche\r\nincrémentale, qui permet des affichage de page plus rapides.\r\n\r\nOn touche là au meilleur des deux mondes. Sur une url données, dans un contexte\r\ndonné, notre serveur nous donnera un HTML parfaitement formé, parfaitement\r\nadapté pour le crawling, le SEO, l'accessibilité, etc. Si le navigateur est en\r\nmesure d'executer React, il peut mettre à jour la vue de manière incrémentale\r\nen redemandant les nouvelles infos au backend, qui peut se permettre de la lui\r\nretourner de manière simple sous forme de data.\r\n\r\n## React, CSS in JS\r\n\r\nLe dernier talk était de Chistophe Chedeau, de chez Facebook (et sans doute\r\nconnu de certains d'entre vous pour son boulot sur Curse Gaming). Il nous\r\na présenté React depuis sa création jusqu'à ce qu'il est aujourd'hui.\r\n\r\nL'idée principale derrière Reacte était de simplifier la codebase de Facebook.\r\nDes milliers d'ingénieurs qui bossent sur du front-end en même temps, avec des\r\ncompétences en HTML/CSS très variées. Il n'y a pas vraiment de dev front chez\r\nFacebook, tous les devs travaillent sur toutes les parties, qu'elles soient\r\nback ou front. Du coup, ils ont souhaité abstraire au maximum certaines parties\r\ndu markup pour limiter les erreurs, et simplifier le développement.\r\n\r\nUn des problèmes majeur de CSS qui se fait ressentir sur une codebase comme\r\ncelle-là, c'est que tout dans CSS est globales. On definit une classe, elle va\r\ns'appliquer partout dans le markup. Certes on peut préfixer un selecteur pour\r\nle rendre plus precis, mais on n'est jamais sur à 100% d'avoir une isolation\r\nparfaite. Un autre dev peux, consciemment ou non, overrider nos styles. En\r\nutilisant une méthode comme BEM, on peut limiter ce problème mais alors on\r\nrends le code extremement difficile à minifier, avec des classes à rallonge sur\r\npresque tous les éléments.\r\n\r\nLe second problème majeur est qu'il est très difficile de supprimer du code. Il\r\nn'y a pas de couverture de code comme dans d'autres langages qui pourrait être\r\ndéduite par des tests unitaires. Quand on supprime du CSS, on ne sait jamais\r\nréellement ce qu'on va casser.\r\n\r\nEt pour finir, ils souhaitaient un moyen simple de pouvoir partager des\r\nconstantes entre PHP, Javascript et CSS (un code couleur, un nombre d'éléments\r\nà afficher, un flag de feature flipping, etc).\r\n\r\nIls ont donc planché sur un moyen de créer des composants isolés, qui chargent\r\nleurs propres dépendances, qui ne se fassent pas overrider par l'extérieur et\r\nqui ne puissent pas non plus le faire.\r\n\r\nLeur action principale, pour obtenir ce pouvoir, a été de convertir le CSS en\r\nJavascript. Tout simplement en React, ils n'écrivent pas leurs propriétés de\r\nstyle dans du CSS mais dans des objets JSON (légérement améliorés avec quelques\r\nhelpers). Cette partie m'a un peu fait peur, et a continué à me suprendre dans\r\nle reste de la présentation. Finalement, après en avoir discuté avec d'autres\r\ndevs qui font déjà du React régulièrement, cette approche n'est pas obligatoire\r\net est même rarement employée : on continue d'utiliser des classes pour le\r\nstyle.\r\n\r\nBref, ces propriétés JSON/CSS sont ensuite appliquées directement en `style=`\r\nsur les éléments du markup. L'avantage de cette méthode barbare est qu'on est\r\ncertain qu'on ne pourra pas se faire overrider par d'autres classes (`style`\r\na la prio la plus forte), et comme on ne déclare pas de classe, on ne va rien\r\noverrider à l'extérieur non plus. C'est assez malin.\r\n\r\nDe plus, ils en profitent pour \"optimiser\" certaines règles au passage (si on\r\nne mets pas d'unité, c'est des px par défaut par exemple) ou comportement (un\r\n`display:none` en React va carrément supprimer le nœud du DOM).\r\n\r\nEn fait, pas mal de comportements du DOM classique sont recodés en Javascript\r\nen React. Quand j'ai vu les `onMouseEnter` / `onMouseLeave` pour recréer le\r\n`:hover` j'étais assez dubitatif quand même. Le speaker annoncait que le fait\r\nd'être particulièrement explicite de cette manière rendait le code plus simple\r\nà comprendre. Je suis pas vraiment convaincu à premier abord, mais pourquoi\r\npas. Par contre, là où je le rejoins c'est que ça rends le code de rendu\r\nvraiment plus facile à style. On peut écrire des tests unitaires qui vont\r\npouvoir manuellement passer un élément en `:hover` et tester un comportement en\r\nallant regarder le contenu de l'objet de style.\r\n\r\nIl a fini par nous expliquer deux-trois autres optimisation que le moteur de\r\nReact opère. Pour moi, ce n'est rien de plus que ce que le moteur natif du\r\nbrowser execute, mais qu'ils ont recodé à la main, et ce qui leur permet de\r\ns'affranchir des différences d'implémentations entre navigateurs. Je ne sais\r\npas trop quoi penser à ce sujet. Certes ça permet de simplifier le dev et\r\nd'offrir la même expérience à tout le monde, mais ça fait réinventer la roue.\r\n\r\nPlus le talk avancait et plus les démonstrations allaient dans ce sens et j'en\r\nsuis sorti en me demandant où ça allait exactement. Vjeux lui même annonçait\r\nque React était jeune, qu'ils ne s'attendaient pas à ce qu'il prenne autant\r\nd'ampleur en dehors de Facebook et qu'ils expérimentent des choses, mais que\r\ntout ne sera peut-être pas bon à garder.\r\n\r\n## Conclusion\r\n\r\nPremier avant-gout de React, j'ai été assez séduit par la simplicité qui s'en\r\ndégage. La dernière conférence m'a laissé plutot dubitatif (comme à chaque\r\nfois qu'on essaie de remplacer CSS par JS parce que _\"CSS c'est trop\r\ncompliqué\"_).\r\n\r\n[React]: http://facebook.github.io/react/\r\n[Deezer]: http://www.deezer.com/\r\n[Altima]: http://www.altima-agency.com/fr\r\n[bloodyowl]: https://twitter.com/bloodyowl\r\n[yannickcr]: https://twitter.com/yannickc\r\n[vjeux]: https://twitter.com/vjeux\r\n\r\n\r\n"
}