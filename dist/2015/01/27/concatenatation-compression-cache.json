{
  "id": "/2015/01/27/concatenatation-compression-cache",
  "title": "Concaténation, Compression, Cache",
  "url": "http://meetups.pixelastic.com//2015/01/27/concatenatation-compression-cache/",
  "tags": [
    "humantalks",
    "webperf"
  ],
  "date": 1422313200,
  "html": "<p>Quand on cherche à optimiser les performances de son site web, il y a trois\néléments essentiels à faire avant toute chose. Trois méthodes très\nsimples à mettre en place et qui apportent un retour direct et flagrant sur la\nvitesse de chargement.</p>\n\n<p>Ces trois méthodes sont la concaténation, la compression et le cache. J&#39;ai déjà\nabordé celles-ci lors d&#39;une <a href=\"https://www.youtube.com/watch?v=ecc1zudWmX4\">présentation aux\nHumanTalks</a> de Septembre 2014,\nmais nous allons les détailler dans la suite de cet article.</p>\n\n<h2>Concaténation</h2>\n\n<p>Le principe de la concaténation est de regrouper plusieurs fichiers de même\ntype en un seul, afin de se retrouver avec moins de fichiers finaux\nà télécharger. Les fichiers qui profitent le plus de ce système sont les\nfichiers CSS et Javascript.</p>\n\n<p>La nature même du téléchargement d&#39;assets fait que notre navigateur doit payer\ncertains coûts, en millisecondes, à chaque nouvel élément téléchargé. Ces coûts\nsont de diverses natures:</p>\n\n<h3>TCP Slow start</h3>\n\n<p>TCP, le protocole de connexion qu&#39;utilise HTTP, possède un mécanisme de\nslow-start qui lui permet de calculer la vitesse optimale de transmission de\nl&#39;information. Pour parvenir à ce résultat, il doit effectuer plusieurs\naller-retours entre le client et le serveur, en envoyant de plus en plus en plus\nde données, pour calculer la vitesse maximale possible d&#39;émission/réception. </p>\n\n<p>Si on envoie une multitude de petits fichiers, la transmission n&#39;a jamais le\ntemps d&#39;atteindre sa vitesse optimale et doit recommencer ses aller-retours\npour le prochain fichier. En groupant les fichiers en un fichier de plus grande\ntaille, le coût de calcul n&#39;est payé qu&#39;une seule fois et le reste du fichier\npeut se télécharger à la vitesse maximum.</p>\n\n<p>À noter que maintenir les connexions à votre serveur en <code>Keep-Alive</code> permet de\nréutiliser une connexion d&#39;un asset vers le suivant et donc de ne payer le coût\nde calcul qu&#39;une fois. Malheureusement, activer le <code>Keep-Alive</code> sur un serveur\nApache risque aussi de limiter le nombre de connexions parallèle que votre\nserveur peut maintenir.</p>\n\n<h3>SSL</h3>\n\n<p>De la même manière, si votre serveur utilise une connexion sécurisée, il y a un\néchange de clés entre le client et le serveur qui s&#39;effectue pour vérifier que\nles deux sont bien qui ils annoncent être. Ici encore, le coût de cet échange\nest payé sur chaque asset téléchargé. Mettre les fichiers en commun permet donc\nde ne payer le coût de cet échange qu&#39;une seule fois.</p>\n\n<h3>Connexions parallèles</h3>\n\n<p>Finalement, il y a une dernière limite, purement du coté du navigateur cette\nfois-ci : le nombre de connexions parallèles. La norme HTTP indique qu&#39;un\nnavigateur devrait ouvrir un maximum de 2 connexions parallèles vers un même\nserveur. Techniquement, les navigateurs récents ont augmenté cette limite à une\nvaleur entre 8 et 12 car 2 était beaucoup trop restrictif.</p>\n\n<p>Cela signifie c&#39;est que si vous demandez à votre page web de télécharger\n5 feuilles de style, 5 scripts et 10 images, le navigateur ne va lancer le\ntéléchargement que des 12 premiers éléments. Il commencera le téléchargement du\n13e uniquement une fois qu&#39;un des 12 premiers sera arrivé, et ainsi de suite.\nIci encore, la concaténation vous permet de laisser plus de canaux disponibles\npour télécharger les autres assets de votre page.</p>\n\n<p>Les fichiers CSS et Javascript se concatènent très bien. Il suffit simplement\nde créer un fichier final qui contient le contenu mis bout-à-bout de tous les\nfichiers initiaux. Votre processus de build devrait pouvoir s&#39;en charger sans\nproblème, mais un solution simple peut s&#39;écrire en quelques lignes :</p>\n<div class=\"highlight\"><pre><code class=\"language-sh\" data-lang=\"sh\">cat ./src/*.css &gt; ./dist/styles.css\ncat ./js/*.js &gt; ./dist/scripts.js\n</code></pre></div>\n<p>À noter que la concaténation d&#39;images (CSS Sprites) est aussi possible, mais\nnous ne l&#39;aborderons pas dans cet article.</p>\n\n<h2>Compression</h2>\n\n<p>Maintenant que nous avons réduit le nombre de fichiers, notre deuxième tâche\nva être de rendre ces fichiers plus légers, afin qu&#39;ils se téléchargent plus\nrapidement.</p>\n\n<p>Pour cela, il existe une formule magique formidable nommée Gzip qui permet de\nréduire de 66% en moyenne le poids des assets textuels.</p>\n\n<p>La bonne nouvelle c&#39;est que la majorité des assets que nous utilisons dans la\ncréation d&#39;un site web sont du texte. Les briques principales comme le HTML, le\nCSS et le Javascript bien sur, mais aussi les formats classiques de retour de\nvotre API : XML et JSON. Et beaucoup d&#39;autres formats qui ne sont en fait que\ndu XML déguisé : flux RSS, webfonts, SVG.</p>\n\n<p>Gzip, et c&#39;est assez rare pour le souligner, est parfaitement interprété par\ntous les serveurs et tous les navigateurs du marché (jusque IE5.5, c&#39;est dire).\nIl n&#39;y a donc aucune raison de ne pas l&#39;utiliser.</p>\n\n<p>Si un navigateur supporte le Gzip, il enverra un header <code>Accept-Encoding: gzip</code>\nau serveur. Si le serveur décèle ce header dans la requête, il compressera le\nfichier à la volée avant de le retourner au client, en y ajoutant le header\n<code>Content-Encoding: gzip</code>, et le client le décompressera à la reception.</p>\n\n<p>L&#39;avantage est donc d&#39;avoir un fichier de taille réduite qui transite sur le\nréseau, avec en contrepartie le serveur et le client qui s&#39;occupent\nrespectivement de la compression/décompression. Sur n&#39;importe quelle machine\nissue des 10 dernières années, l&#39;overhead de la compression/décompression en\ngzip est absolument négligeable. Par contre, le fait d&#39;avoir un fichier bien\nplus léger qui transite sur le réseau permet des gains très importants.</p>\n\n<p>Les librairies de compression Gzip sont disponibles sur tous les serveurs du\nmarché, il suffit généralement simplement de les activer en leur indiquant les\ntypes de fichiers qui doivent être compressées. Vous trouverez ci-dessous\nquelques exemples sur les serveurs les plus connus :</p>\n\n<h4>Apache</h4>\n<div class=\"highlight\"><pre><code class=\"language-apache\" data-lang=\"apache\"><span class=\"nt\">&lt;IfModule</span> <span class=\"s\">mod_deflate.c</span><span class=\"nt\">&gt;</span>\n  <span class=\"nt\">&lt;IfModule</span> <span class=\"s\">mod_filter.c</span><span class=\"nt\">&gt;</span>\n    <span class=\"nb\">AddOutputFilterByType</span> DEFLATE <span class=\"s2\">&quot;application/javascript&quot;</span> <span class=\"s2\">&quot;application/json&quot;</span> \\\n    <span class=\"err\">&quot;text/css&quot;</span> <span class=\"err\">&quot;text/html&quot;</span> <span class=\"err\">&quot;text/xml&quot;</span> <span class=\"err\">[</span>...<span class=\"err\">]</span>\n  <span class=\"nt\">&lt;/IfModule&gt;</span>\n<span class=\"nt\">&lt;/IfModule&gt;</span>\n</code></pre></div>\n<h4>Lighttpd</h4>\n<div class=\"highlight\"><pre><code class=\"language-lighttpd\" data-lang=\"lighttpd\"><span class=\"k\">server.modules</span> <span class=\"o\">+=</span> <span class=\"p\">(</span> <span class=\"s2\">&quot;mod_compress&quot;</span> <span class=\"p\">)</span>\n<span class=\"k\">compress.filetype</span>  <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s2\">&quot;application/javascript&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;application/json&quot;</span><span class=\"p\">,</span> <span class=\"err\">\\</span>\n<span class=\"s2\">&quot;text/css&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;text/html&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;text/xml&quot;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"k\">...</span><span class=\"p\">]</span> <span class=\"p\">)</span>\n</code></pre></div>\n<h4>Nginx</h4>\n<div class=\"highlight\"><pre><code class=\"language-nginx\" data-lang=\"nginx\"><span class=\"k\">gzip</span> <span class=\"no\">on</span><span class=\"p\">;</span>\n<span class=\"k\">gzip_comp_level</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n<span class=\"k\">gzip_types</span> <span class=\"s\">application/javascript</span> <span class=\"s\">application/json</span> <span class=\"s\">text/css</span> <span class=\"s\">text/html</span> <span class=\"s\">text/xml</span>\n<span class=\"s\">[...]</span><span class=\"p\">;</span> \n</code></pre></div>\n<p>S&#39;il y a bien une optimisation de performance qui nécessite peu de travail\nà mettre en place et qui améliore grandement les performances de chargement,\nc&#39;est bien le Gzip. Cela ne nécessite aucun changement sur les fichiers servis,\nuniquement une activation de config sur le serveur.</p>\n\n<h3>Minification</h3>\n\n<p>Pour aller plus loin, vous pouvez aussi investir sur la minification de vos\nassets. HTML, CSS et Javascript sont encore une fois les meilleurs candidats\npour la minification. </p>\n\n<p>La minification est un procédé qui va ré-écrire le code de vos assets dans une\nversion qui utilise moins de caractères, et qui donc pésera moins lourd sur le\nréseau. D&#39;une manière générale cela va surtout supprimer les commentaires et\nles sauts de ligne, mais des minificateurs plus spécialisés pourront renommer\nles variables de vos Javascript en des valeurs plus courtes, regrouper vos\nsélecteurs CSS ou supprimer les attributs redondants de vos pages HTML.</p>\n\n<p>L&#39;ajout d&#39;un processus de minification est plus complexe que l&#39;activation du\nGzip, et les gains sont aussi moins importants. C&#39;est pourquoi nous vous\nconseillons de toujours commencer par la compression Gzip.</p>\n\n<h2>Cache</h2>\n\n<p>À présent que nous avons réussi à limiter le nombre de fichiers et à faire\nbaisser leur poids, la prochaine étape est de les télécharger le moins souvent\npossible.</p>\n\n<p>L&#39;idée principale ici est qu&#39;il est inutile de faire télécharger à votre\nvisiteur un contenu qu&#39;il a déjà téléchargé et possède donc en local sur son\nposte.</p>\n\n<p>Nous allons commencer par expliquer comment fonctionne le cache HTTP car c&#39;est\nun domaine qui est généralement mal compris des développeurs. Il y a en fait\ndeux principes fondamentaux à comprendre dans le cache HTTP: la <em>fraicheur</em>, et\nla <em>validation</em>.</p>\n\n<h3>Fraicheur</h3>\n\n<p>On peut voir la fraicheur d&#39;un asset comme une date limite de consommation.\nLorsque l&#39;on télécharge un élément depuis le serveur, celui-ci nous l&#39;envoie\naccompagné d&#39;un header indiquant jusqu&#39;à quelle date cet élément est encore\nfrais.</p>\n\n<p>Si jamais le client à besoin à nouveau du même élément, il commence par\nvérifier la fraicheur de celui qu&#39;il a en cache. S&#39;il est encore frais, il ne\nfait pas de requête au serveur, et utilise directement celui qu&#39;il a sur son\ndisque. On ne peut pas faire plus rapide, car il n&#39;y a alors absolument aucune\nconnexion réseau impliquée.</p>\n\n<p>Par contre, si jamais la date de fraicheur est dépassée, alors le navigateur va\nlancer une nouvelle requête au serveur pour récupérer la nouvelle version.</p>\n\n<p>En HTTP 1.0, le serveur retourne un header <code>Expires</code> avec la date limite de\nfraicheur. Par exemple: <code>Expires: Thu, 04 May 2014 20:00:00 GMT</code>. Dans cet\nexemple, si jamais le navigateur demande à nouveau le même asset avant le 4 Mai\n2014 à 20h, alors il le lira depuis son cache, sinon il interrogera le serveur.</p>\n\n<p>Cette notation a un défaut majeur dans le fait que les dates sont fixées de\nmanière absolue. Cela signifie que le cache de tous les clients perdra sa\nfraicheur en même temps. Et vous aurez donc potentiellement tous les clients\nqui feront une nouvelle requête vers votre serveur en même temps pour se mettre\nà jour, ce qui peut générer un très fort pic de charge à cet instant.</p>\n\n<p>Pour limiter cela et donner plus de flexibilité dans la gestion de la\nfraicheur, en HTTP 1.1, un nouveau header à été introduit : <code>Cache-Control</code>.\nCelui-ci accepte plusieurs arguments qui permettent de gérer plus finement la\nmanière de mettre en cache, et celui qui nous intéresse ici est <code>max-age</code> qui\npermet de définir une durée relative de fraicheur, en secondes.</p>\n\n<p>Votre serveur peut donc répondre <code>Cache-Control: max-age=3600</code> pour indiquer\nque l&#39;asset est encore frais pendant 1h (3600 secondes). En faisant ainsi vous\npouvez espacer les appels sur une plus longue période.</p>\n\n<h3>Validation</h3>\n\n<p>La deuxième composante du cache est la <em>validation</em>. Imaginons que notre asset\nai terminé sa période de fraicheur, nous allons donc récupérer une nouvelle\nversion de celui-ci sur le serveur. Mais il est possible que l&#39;asset n&#39;ait pas\nréellement changé sur le serveur depuis la dernière fois. Il serait alors\ninutile de retélécharger quelque chose que nous avons déjà dans notre cache.</p>\n\n<p>Le principe de validation permet au serveur de gérer cela. Soit l&#39;asset du\nclient est identique à l&#39;asset du serveur, dans ce cas le client peut garder sa\nversion locale. Soit les deux sont différents et dans ce cas le client doit\nmettre à jour son cache avec la version distante.</p>\n\n<p>Lorsque le client a récupéré l&#39;asset pour la première fois, le serveur lui\na répondu avec un header <code>Last-Modified</code>, par exemple <code>Last-Modified: Mon, 04\nMay 2014 02:28:12 GMT</code>. La prochaine fois que le client fera une requête pour\nrécupérer cet asset, il renverra la date dans son header <code>If-Modified-Since</code>,\npar exemple <code>If-Modified-Since: Mon, 04 May 2014 02:28:12 GMT</code>.</p>\n\n<p>Le serveur compare alors la date envoyée et celle qu&#39;il possède de son coté.\nSi les deux correspondent, alors il renverra un <code>304 Not Modified</code> pour\nindiquer au client que le contenu n&#39;a pas changé. Celui-ci continuera alors\nd&#39;utiliser sa version locale. Ainsi, on évite de transmettre du contenu inutile\nsur le réseau.</p>\n\n<p>Par contre si le serveur voit que le fichier qu&#39;il possède est plus récent que\nla date envoyée, il répondra avec un <code>200 OK</code> et le nouveau contenu. Ainsi, le\nclient utilise désormais la dernière version. </p>\n\n<p>En faisant ainsi, on évite donc de télécharger un contenu qu&#39;on possède déjà.</p>\n\n<p>Dans les deux cas, le serveur renvoie de nouvelles informations de fraicheur.</p>\n\n<p>Comme pour la fraicheur, il existe deux couples de headers pour communiquer des\ninformations de validation au serveur. En plus de <code>Last-Modified</code>\n/ <code>If-Modified-Since</code> qui utilisent une date de modification, il est possible\nd&#39;utiliser des ETags.</p>\n\n<p>Un ETag est un hash qui identifie de manière unique chaque fichier. Si le\nfichier change, alors son ETag change aussi. Par exemple, le serveur retourne\nau client lors du premier appel un header <code>ETag: &quot;3e86-410-3596fbbc&quot;</code>, et\nlorsque le client fait à nouveau appel à la même ressource, il envoie un header\n<code>If-None-Match : &quot;3e86-410-3596fbbc&quot;</code>. Le serveur va comparer les deux ETags et\nretourner un <code>304 Not Modified</code> s&#39;ils sont identiques ou un <code>200 OK</code> avec le\nnouveau contenu s&#39;ils sont différents.</p>\n\n<p><code>Last-Modified</code> et <code>ETag</code> possèdent des comportements très similaires, mais\nnous vous conseillons d&#39;utiliser <code>Last-Modified</code> en priorité.</p>\n\n<p>En effet, la spec HTTP indique que si un serveur retourne un <code>Last-Modified</code> et\nun <code>ETag</code>, alors le navigateur doit prendre en priorité le <code>Last-Modified</code>. De\nplus, la majorité des serveurs génèrent l&#39;ETag à partir de l&#39;inode du fichier,\nde manière à ce que celui-ci soit modifié au moindre changement.</p>\n\n<p>Malheureusement, ceci pose des soucis pour peu que vous ayez des serveurs\nredondés derrière un load-balancer où chaque serveur possède son propre\nfilesystem et donc ses propres inodes. Deux fichiers identiques, sur deux\nserveurs différents auront des inodes différents et par conséquent des ETag\ndifférents.  Votre système de validation ne fonctionnera plus dès lors que\nvotre client sera redirigé vers un autre frontal.</p>\n\n<p>À noter que ce problème n&#39;apparait pas sous nginx, qui ne prends pas en compte\nl&#39;inode dans la génération de son ETag. Sous Apache, l&#39;option <code>FileEtag MTime\nSize</code> permet de le désactiver, ainsi que <code>etag.use-inode = &quot;disable&quot;</code> sous\nlighttpd.</p>\n\n<h3>Récapitulatif</h3>\n\n<p>À la lumière de ces explications, nous pouvons donc retracer le parcours\nclassique du téléchargement d&#39;un asset mis en cache.</p>\n\n<ul>\n<li>Le client effectue une première requête pour récupérer un asset. Il récupère\nson <code>Cache-Control: max-age</code> pour la fraicheur et son <code>Last-Modified</code> pour la\nvalidation.</li>\n<li>S&#39;il demande à nouveau le même asset alors que celui-ci est encore frais, il\nle prends directement depuis son disque local.</li>\n<li>S&#39;il le demande au dela de sa date de fraicheur, il fait un appel au serveur\nen envoyant son <code>If-Modified-Since</code>.</li>\n<li>Si le fichier sur le serveur possède la même date de modification que celle\nenvoyée, il retourne un <code>304 Not Modified</code>.</li>\n<li>Si le fichier sur le serveur a été modifié, il retourne un <code>200 OK</code> avec le\nnouveau contenu.</li>\n<li>Dans tous les cas, le serveur retourne un <code>Cache-Control</code> et un\n<code>Last-Modified</code>.</li>\n</ul>\n\n<h3>Invalidation du cache</h3>\n\n<p>Mais le cache est un animal capricieux, et nous savons tous que :</p>\n\n<blockquote>\n<p>Il y a deux choses complexes en informatique : invalider le cache et nommer\nles choses.</p>\n</blockquote>\n\n<p>Et effectivement, invalider le cache de nos clients quand nous avons besoin de\nfaire une mise à jour est extrêmement difficile. C&#39;est en fait tellement\ndifficile que nous n&#39;allons pas le faire du tout.</p>\n\n<p>Comme le navigateur mets en cache chaque URL, si nous souhaitons modifier un\ncontenu, il nous suffit de modifier son URL. Et les URL, c&#39;est quelque chose\nque nous avons en quantité illimité. Il nous suffit de modifier le nom d&#39;un\nfichier pour générer un nouvelle URL. On peut ajouter un numero de version,\nun timestamp ou un hash à notre nom de fichier original pour lui générer une\nnouvelle url. </p>\n\n<p>Par exemple : <code>style-c9b5fd6520f5ab77dd823b1b2c81ff9c461b1374.css</code> au lieu de\n<code>style.css</code>.</p>\n\n<p>En mettant un cache très long sur ces assets (1 an est le maximum officiel de\nla spec), c&#39;est comme si on les gardait en cache indéfiniment. Il nous suffit\njuste de mettre un cache plus court sur le fichier qui les référence\n(généralement le fichier HTML).</p>\n\n<p>Ainsi, si on pousse en production une modification sur une feuille de style ou\ndans un script, il nous suffit de modifier les références à ces fichiers dans\nnos sources HTML pour que les clients téléchargent les nouveaux contenus. Le\ncache sur les fichiers HTML est beaucoup plus court, de manière à ce que les\nchangements introduits par notre mise en production soient rapidement\nrépércutées sur nos clients.</p>\n\n<p>Les anciens contenus seront encore en cache chez nos clients mais cela n&#39;a pas\nd&#39;importance, nous ne les requêterons plus jamais et les éléments non-utilisés\ndu cache des clients se vident régulièrement.</p>\n\n<p>La technique est en fait très proche des <code>Etag</code> vus précédement à la différence\nqu&#39;ici nous sommes maitres de la génération du nom unique de fichier et du\nmoment où nous souhaitons invalider le cache de nos clients.</p>\n\n<p>Au final, nous utilisons un mélange de ces deux techniques pour gérer un cache\noptimal. </p>\n\n<p>Les éléments dont l&#39;URL est significative, comme les pages HTML ou les\nretours d&#39;une API définiront une fraicheur faible (de quelques minutes\nà quelques heures, en fonction de la fréquence moyenne de mise à jour). Ceci\npermet de s&#39;assurer que le client aura rapidement la nouvelle version quand\ncelle-ci est déployée, tout en limitant la charge sur le serveur et la quantité\nd&#39;information transitant sur le réseau.</p>\n\n<p>Pour les éléments dont l&#39;URL n&#39;est pas significative, comme les feuilles de\nstyles, les scripts, les polices de caractère ou les images, on utilisera une\nfraicheur maximum d&#39;un an. Ceci permettra au client de garder indéfiniment la\nressource dans son cache sans avoir besoin d&#39;interroger à nouveau le serveur.\nOn générera par contre une URL différente en fonction d&#39;un hash du contenu\nà chaque fois que le contenu vient à changer. On prendra bien garde à modifier\nles références à ces fichiers dans les pages HTML.</p>\n\n<h2>Conclusion</h2>\n\n<p>Nous avons donc vu comment trois points très simples permettent de diminuer\ngrandement le nombre de total de fichiers à télécharger, les rendre plus\nlégers, et les télécharger moins souvent.</p>\n\n<p>La concaténation automatique des fichiers doit être intégrée dans votre\nprocessus de build, afin de garder un environnement de développement clair. La\ncompression en gzip ne nécessite que quelques modifications sur vos serveurs.\nLa mise en place d&#39;une stratégie de cache optimale par contre nécessite à la\nfois des modifications sur le processus de build et sur la configuration des\nserveurs.</p>\n\n<p>Toutes ces modifications sont relativement peu couteuses à mettre en place et\nne dépendent aucunement ni de la technologie utilisée pour le front-end, ni de\ncelle utilisée pour le back-end. Elles peuvent être mise en place quelle que\nsoit votre stack technique. Il n&#39;y a donc plus aucune raison pour ne pas les\ndéployer dès aujourd&#39;hui.</p>\n",
  "markdown": "Quand on cherche à optimiser les performances de son site web, il y a trois\r\néléments essentiels à faire avant toute chose. Trois méthodes très\r\nsimples à mettre en place et qui apportent un retour direct et flagrant sur la\r\nvitesse de chargement.\r\n\r\nCes trois méthodes sont la concaténation, la compression et le cache. J'ai déjà\r\nabordé celles-ci lors d'une [présentation aux\r\nHumanTalks](https://www.youtube.com/watch?v=ecc1zudWmX4) de Septembre 2014,\r\nmais nous allons les détailler dans la suite de cet article.\r\n\r\n## Concaténation\r\n\r\nLe principe de la concaténation est de regrouper plusieurs fichiers de même\r\ntype en un seul, afin de se retrouver avec moins de fichiers finaux\r\nà télécharger. Les fichiers qui profitent le plus de ce système sont les\r\nfichiers CSS et Javascript.\r\n\r\nLa nature même du téléchargement d'assets fait que notre navigateur doit payer\r\ncertains coûts, en millisecondes, à chaque nouvel élément téléchargé. Ces coûts\r\nsont de diverses natures:\r\n\r\n### TCP Slow start\r\n\r\nTCP, le protocole de connexion qu'utilise HTTP, possède un mécanisme de\r\nslow-start qui lui permet de calculer la vitesse optimale de transmission de\r\nl'information. Pour parvenir à ce résultat, il doit effectuer plusieurs\r\naller-retours entre le client et le serveur, en envoyant de plus en plus en plus\r\nde données, pour calculer la vitesse maximale possible d'émission/réception. \r\n\r\nSi on envoie une multitude de petits fichiers, la transmission n'a jamais le\r\ntemps d'atteindre sa vitesse optimale et doit recommencer ses aller-retours\r\npour le prochain fichier. En groupant les fichiers en un fichier de plus grande\r\ntaille, le coût de calcul n'est payé qu'une seule fois et le reste du fichier\r\npeut se télécharger à la vitesse maximum.\r\n\r\nÀ noter que maintenir les connexions à votre serveur en `Keep-Alive` permet de\r\nréutiliser une connexion d'un asset vers le suivant et donc de ne payer le coût\r\nde calcul qu'une fois. Malheureusement, activer le `Keep-Alive` sur un serveur\r\nApache risque aussi de limiter le nombre de connexions parallèle que votre\r\nserveur peut maintenir.\r\n\r\n### SSL\r\n\r\nDe la même manière, si votre serveur utilise une connexion sécurisée, il y a un\r\néchange de clés entre le client et le serveur qui s'effectue pour vérifier que\r\nles deux sont bien qui ils annoncent être. Ici encore, le coût de cet échange\r\nest payé sur chaque asset téléchargé. Mettre les fichiers en commun permet donc\r\nde ne payer le coût de cet échange qu'une seule fois.\r\n\r\n### Connexions parallèles\r\n\r\nFinalement, il y a une dernière limite, purement du coté du navigateur cette\r\nfois-ci : le nombre de connexions parallèles. La norme HTTP indique qu'un\r\nnavigateur devrait ouvrir un maximum de 2 connexions parallèles vers un même\r\nserveur. Techniquement, les navigateurs récents ont augmenté cette limite à une\r\nvaleur entre 8 et 12 car 2 était beaucoup trop restrictif.\r\n\r\nCela signifie c'est que si vous demandez à votre page web de télécharger\r\n5 feuilles de style, 5 scripts et 10 images, le navigateur ne va lancer le\r\ntéléchargement que des 12 premiers éléments. Il commencera le téléchargement du\r\n13e uniquement une fois qu'un des 12 premiers sera arrivé, et ainsi de suite.\r\nIci encore, la concaténation vous permet de laisser plus de canaux disponibles\r\npour télécharger les autres assets de votre page.\r\n\r\nLes fichiers CSS et Javascript se concatènent très bien. Il suffit simplement\r\nde créer un fichier final qui contient le contenu mis bout-à-bout de tous les\r\nfichiers initiaux. Votre processus de build devrait pouvoir s'en charger sans\r\nproblème, mais un solution simple peut s'écrire en quelques lignes :\r\n\r\n```sh\r\ncat ./src/*.css > ./dist/styles.css\r\ncat ./js/*.js > ./dist/scripts.js\r\n```\r\n\r\nÀ noter que la concaténation d'images (CSS Sprites) est aussi possible, mais\r\nnous ne l'aborderons pas dans cet article.\r\n\r\n## Compression\r\n\r\nMaintenant que nous avons réduit le nombre de fichiers, notre deuxième tâche\r\nva être de rendre ces fichiers plus légers, afin qu'ils se téléchargent plus\r\nrapidement.\r\n\r\nPour cela, il existe une formule magique formidable nommée Gzip qui permet de\r\nréduire de 66% en moyenne le poids des assets textuels.\r\n\r\nLa bonne nouvelle c'est que la majorité des assets que nous utilisons dans la\r\ncréation d'un site web sont du texte. Les briques principales comme le HTML, le\r\nCSS et le Javascript bien sur, mais aussi les formats classiques de retour de\r\nvotre API : XML et JSON. Et beaucoup d'autres formats qui ne sont en fait que\r\ndu XML déguisé : flux RSS, webfonts, SVG.\r\n\r\nGzip, et c'est assez rare pour le souligner, est parfaitement interprété par\r\ntous les serveurs et tous les navigateurs du marché (jusque IE5.5, c'est dire).\r\nIl n'y a donc aucune raison de ne pas l'utiliser.\r\n\r\nSi un navigateur supporte le Gzip, il enverra un header `Accept-Encoding: gzip`\r\nau serveur. Si le serveur décèle ce header dans la requête, il compressera le\r\nfichier à la volée avant de le retourner au client, en y ajoutant le header\r\n`Content-Encoding: gzip`, et le client le décompressera à la reception.\r\n\r\nL'avantage est donc d'avoir un fichier de taille réduite qui transite sur le\r\nréseau, avec en contrepartie le serveur et le client qui s'occupent\r\nrespectivement de la compression/décompression. Sur n'importe quelle machine\r\nissue des 10 dernières années, l'overhead de la compression/décompression en\r\ngzip est absolument négligeable. Par contre, le fait d'avoir un fichier bien\r\nplus léger qui transite sur le réseau permet des gains très importants.\r\n\r\nLes librairies de compression Gzip sont disponibles sur tous les serveurs du\r\nmarché, il suffit généralement simplement de les activer en leur indiquant les\r\ntypes de fichiers qui doivent être compressées. Vous trouverez ci-dessous\r\nquelques exemples sur les serveurs les plus connus :\r\n\r\n#### Apache\r\n```apache\r\n<IfModule mod_deflate.c>\r\n  <IfModule mod_filter.c>\r\n    AddOutputFilterByType DEFLATE \"application/javascript\" \"application/json\" \\\r\n    \"text/css\" \"text/html\" \"text/xml\" [...]\r\n  </IfModule>\r\n</IfModule>\r\n```\r\n\r\n#### Lighttpd\r\n```lighttpd\r\nserver.modules += ( \"mod_compress\" )\r\ncompress.filetype  = (\"application/javascript\", \"application/json\", \\\r\n\"text/css\", \"text/html\", \"text/xml\", [...] )\r\n```\r\n\r\n#### Nginx\r\n```nginx\r\ngzip on;\r\ngzip_comp_level 6;\r\ngzip_types application/javascript application/json text/css text/html text/xml\r\n[...]; \r\n```\r\n\r\nS'il y a bien une optimisation de performance qui nécessite peu de travail\r\nà mettre en place et qui améliore grandement les performances de chargement,\r\nc'est bien le Gzip. Cela ne nécessite aucun changement sur les fichiers servis,\r\nuniquement une activation de config sur le serveur.\r\n\r\n### Minification\r\n\r\nPour aller plus loin, vous pouvez aussi investir sur la minification de vos\r\nassets. HTML, CSS et Javascript sont encore une fois les meilleurs candidats\r\npour la minification. \r\n\r\nLa minification est un procédé qui va ré-écrire le code de vos assets dans une\r\nversion qui utilise moins de caractères, et qui donc pésera moins lourd sur le\r\nréseau. D'une manière générale cela va surtout supprimer les commentaires et\r\nles sauts de ligne, mais des minificateurs plus spécialisés pourront renommer\r\nles variables de vos Javascript en des valeurs plus courtes, regrouper vos\r\nsélecteurs CSS ou supprimer les attributs redondants de vos pages HTML.\r\n\r\nL'ajout d'un processus de minification est plus complexe que l'activation du\r\nGzip, et les gains sont aussi moins importants. C'est pourquoi nous vous\r\nconseillons de toujours commencer par la compression Gzip.\r\n\r\n## Cache\r\n\r\nÀ présent que nous avons réussi à limiter le nombre de fichiers et à faire\r\nbaisser leur poids, la prochaine étape est de les télécharger le moins souvent\r\npossible.\r\n\r\nL'idée principale ici est qu'il est inutile de faire télécharger à votre\r\nvisiteur un contenu qu'il a déjà téléchargé et possède donc en local sur son\r\nposte.\r\n\r\nNous allons commencer par expliquer comment fonctionne le cache HTTP car c'est\r\nun domaine qui est généralement mal compris des développeurs. Il y a en fait\r\ndeux principes fondamentaux à comprendre dans le cache HTTP: la _fraicheur_, et\r\nla _validation_.\r\n\r\n### Fraicheur\r\n\r\nOn peut voir la fraicheur d'un asset comme une date limite de consommation.\r\nLorsque l'on télécharge un élément depuis le serveur, celui-ci nous l'envoie\r\naccompagné d'un header indiquant jusqu'à quelle date cet élément est encore\r\nfrais.\r\n\r\nSi jamais le client à besoin à nouveau du même élément, il commence par\r\nvérifier la fraicheur de celui qu'il a en cache. S'il est encore frais, il ne\r\nfait pas de requête au serveur, et utilise directement celui qu'il a sur son\r\ndisque. On ne peut pas faire plus rapide, car il n'y a alors absolument aucune\r\nconnexion réseau impliquée.\r\n\r\nPar contre, si jamais la date de fraicheur est dépassée, alors le navigateur va\r\nlancer une nouvelle requête au serveur pour récupérer la nouvelle version.\r\n\r\nEn HTTP 1.0, le serveur retourne un header `Expires` avec la date limite de\r\nfraicheur. Par exemple: `Expires: Thu, 04 May 2014 20:00:00 GMT`. Dans cet\r\nexemple, si jamais le navigateur demande à nouveau le même asset avant le 4 Mai\r\n2014 à 20h, alors il le lira depuis son cache, sinon il interrogera le serveur.\r\n\r\nCette notation a un défaut majeur dans le fait que les dates sont fixées de\r\nmanière absolue. Cela signifie que le cache de tous les clients perdra sa\r\nfraicheur en même temps. Et vous aurez donc potentiellement tous les clients\r\nqui feront une nouvelle requête vers votre serveur en même temps pour se mettre\r\nà jour, ce qui peut générer un très fort pic de charge à cet instant.\r\n\r\nPour limiter cela et donner plus de flexibilité dans la gestion de la\r\nfraicheur, en HTTP 1.1, un nouveau header à été introduit : `Cache-Control`.\r\nCelui-ci accepte plusieurs arguments qui permettent de gérer plus finement la\r\nmanière de mettre en cache, et celui qui nous intéresse ici est `max-age` qui\r\npermet de définir une durée relative de fraicheur, en secondes.\r\n\r\nVotre serveur peut donc répondre `Cache-Control: max-age=3600` pour indiquer\r\nque l'asset est encore frais pendant 1h (3600 secondes). En faisant ainsi vous\r\npouvez espacer les appels sur une plus longue période.\r\n\r\n### Validation\r\n\r\nLa deuxième composante du cache est la _validation_. Imaginons que notre asset\r\nai terminé sa période de fraicheur, nous allons donc récupérer une nouvelle\r\nversion de celui-ci sur le serveur. Mais il est possible que l'asset n'ait pas\r\nréellement changé sur le serveur depuis la dernière fois. Il serait alors\r\ninutile de retélécharger quelque chose que nous avons déjà dans notre cache.\r\n\r\nLe principe de validation permet au serveur de gérer cela. Soit l'asset du\r\nclient est identique à l'asset du serveur, dans ce cas le client peut garder sa\r\nversion locale. Soit les deux sont différents et dans ce cas le client doit\r\nmettre à jour son cache avec la version distante.\r\n\r\nLorsque le client a récupéré l'asset pour la première fois, le serveur lui\r\na répondu avec un header `Last-Modified`, par exemple `Last-Modified: Mon, 04\r\nMay 2014 02:28:12 GMT`. La prochaine fois que le client fera une requête pour\r\nrécupérer cet asset, il renverra la date dans son header `If-Modified-Since`,\r\npar exemple `If-Modified-Since: Mon, 04 May 2014 02:28:12 GMT`.\r\n\r\nLe serveur compare alors la date envoyée et celle qu'il possède de son coté.\r\nSi les deux correspondent, alors il renverra un `304 Not Modified` pour\r\nindiquer au client que le contenu n'a pas changé. Celui-ci continuera alors\r\nd'utiliser sa version locale. Ainsi, on évite de transmettre du contenu inutile\r\nsur le réseau.\r\n\r\nPar contre si le serveur voit que le fichier qu'il possède est plus récent que\r\nla date envoyée, il répondra avec un `200 OK` et le nouveau contenu. Ainsi, le\r\nclient utilise désormais la dernière version. \r\n\r\nEn faisant ainsi, on évite donc de télécharger un contenu qu'on possède déjà.\r\n\r\nDans les deux cas, le serveur renvoie de nouvelles informations de fraicheur.\r\n\r\nComme pour la fraicheur, il existe deux couples de headers pour communiquer des\r\ninformations de validation au serveur. En plus de `Last-Modified`\r\n/ `If-Modified-Since` qui utilisent une date de modification, il est possible\r\nd'utiliser des ETags.\r\n\r\nUn ETag est un hash qui identifie de manière unique chaque fichier. Si le\r\nfichier change, alors son ETag change aussi. Par exemple, le serveur retourne\r\nau client lors du premier appel un header `ETag: \"3e86-410-3596fbbc\"`, et\r\nlorsque le client fait à nouveau appel à la même ressource, il envoie un header\r\n`If-None-Match : \"3e86-410-3596fbbc\"`. Le serveur va comparer les deux ETags et\r\nretourner un `304 Not Modified` s'ils sont identiques ou un `200 OK` avec le\r\nnouveau contenu s'ils sont différents.\r\n\r\n`Last-Modified` et `ETag` possèdent des comportements très similaires, mais\r\nnous vous conseillons d'utiliser `Last-Modified` en priorité.\r\n\r\nEn effet, la spec HTTP indique que si un serveur retourne un `Last-Modified` et\r\nun `ETag`, alors le navigateur doit prendre en priorité le `Last-Modified`. De\r\nplus, la majorité des serveurs génèrent l'ETag à partir de l'inode du fichier,\r\nde manière à ce que celui-ci soit modifié au moindre changement.\r\n\r\nMalheureusement, ceci pose des soucis pour peu que vous ayez des serveurs\r\nredondés derrière un load-balancer où chaque serveur possède son propre\r\nfilesystem et donc ses propres inodes. Deux fichiers identiques, sur deux\r\nserveurs différents auront des inodes différents et par conséquent des ETag\r\ndifférents.  Votre système de validation ne fonctionnera plus dès lors que\r\nvotre client sera redirigé vers un autre frontal.\r\n\r\nÀ noter que ce problème n'apparait pas sous nginx, qui ne prends pas en compte\r\nl'inode dans la génération de son ETag. Sous Apache, l'option `FileEtag MTime\r\nSize` permet de le désactiver, ainsi que `etag.use-inode = \"disable\"` sous\r\nlighttpd.\r\n\r\n### Récapitulatif\r\n\r\nÀ la lumière de ces explications, nous pouvons donc retracer le parcours\r\nclassique du téléchargement d'un asset mis en cache.\r\n\r\n- Le client effectue une première requête pour récupérer un asset. Il récupère\r\n  son `Cache-Control: max-age` pour la fraicheur et son `Last-Modified` pour la\r\n  validation.\r\n- S'il demande à nouveau le même asset alors que celui-ci est encore frais, il\r\n  le prends directement depuis son disque local.\r\n- S'il le demande au dela de sa date de fraicheur, il fait un appel au serveur\r\n  en envoyant son `If-Modified-Since`.\r\n- Si le fichier sur le serveur possède la même date de modification que celle\r\n  envoyée, il retourne un `304 Not Modified`.\r\n- Si le fichier sur le serveur a été modifié, il retourne un `200 OK` avec le\r\n  nouveau contenu.\r\n- Dans tous les cas, le serveur retourne un `Cache-Control` et un\r\n  `Last-Modified`.\r\n\r\n### Invalidation du cache\r\n\r\nMais le cache est un animal capricieux, et nous savons tous que :\r\n\r\n> Il y a deux choses complexes en informatique : invalider le cache et nommer\r\n> les choses.\r\n\r\nEt effectivement, invalider le cache de nos clients quand nous avons besoin de\r\nfaire une mise à jour est extrêmement difficile. C'est en fait tellement\r\ndifficile que nous n'allons pas le faire du tout.\r\n\r\nComme le navigateur mets en cache chaque URL, si nous souhaitons modifier un\r\ncontenu, il nous suffit de modifier son URL. Et les URL, c'est quelque chose\r\nque nous avons en quantité illimité. Il nous suffit de modifier le nom d'un\r\nfichier pour générer un nouvelle URL. On peut ajouter un numero de version,\r\nun timestamp ou un hash à notre nom de fichier original pour lui générer une\r\nnouvelle url. \r\n\r\nPar exemple : `style-c9b5fd6520f5ab77dd823b1b2c81ff9c461b1374.css` au lieu de\r\n`style.css`.\r\n\r\nEn mettant un cache très long sur ces assets (1 an est le maximum officiel de\r\nla spec), c'est comme si on les gardait en cache indéfiniment. Il nous suffit\r\njuste de mettre un cache plus court sur le fichier qui les référence\r\n(généralement le fichier HTML).\r\n\r\nAinsi, si on pousse en production une modification sur une feuille de style ou\r\ndans un script, il nous suffit de modifier les références à ces fichiers dans\r\nnos sources HTML pour que les clients téléchargent les nouveaux contenus. Le\r\ncache sur les fichiers HTML est beaucoup plus court, de manière à ce que les\r\nchangements introduits par notre mise en production soient rapidement\r\nrépércutées sur nos clients.\r\n\r\nLes anciens contenus seront encore en cache chez nos clients mais cela n'a pas\r\nd'importance, nous ne les requêterons plus jamais et les éléments non-utilisés\r\ndu cache des clients se vident régulièrement.\r\n\r\nLa technique est en fait très proche des `Etag` vus précédement à la différence\r\nqu'ici nous sommes maitres de la génération du nom unique de fichier et du\r\nmoment où nous souhaitons invalider le cache de nos clients.\r\n\r\nAu final, nous utilisons un mélange de ces deux techniques pour gérer un cache\r\noptimal. \r\n\r\nLes éléments dont l'URL est significative, comme les pages HTML ou les\r\nretours d'une API définiront une fraicheur faible (de quelques minutes\r\nà quelques heures, en fonction de la fréquence moyenne de mise à jour). Ceci\r\npermet de s'assurer que le client aura rapidement la nouvelle version quand\r\ncelle-ci est déployée, tout en limitant la charge sur le serveur et la quantité\r\nd'information transitant sur le réseau.\r\n\r\nPour les éléments dont l'URL n'est pas significative, comme les feuilles de\r\nstyles, les scripts, les polices de caractère ou les images, on utilisera une\r\nfraicheur maximum d'un an. Ceci permettra au client de garder indéfiniment la\r\nressource dans son cache sans avoir besoin d'interroger à nouveau le serveur.\r\nOn générera par contre une URL différente en fonction d'un hash du contenu\r\nà chaque fois que le contenu vient à changer. On prendra bien garde à modifier\r\nles références à ces fichiers dans les pages HTML.\r\n\r\n## Conclusion\r\n\r\nNous avons donc vu comment trois points très simples permettent de diminuer\r\ngrandement le nombre de total de fichiers à télécharger, les rendre plus\r\nlégers, et les télécharger moins souvent.\r\n\r\nLa concaténation automatique des fichiers doit être intégrée dans votre\r\nprocessus de build, afin de garder un environnement de développement clair. La\r\ncompression en gzip ne nécessite que quelques modifications sur vos serveurs.\r\nLa mise en place d'une stratégie de cache optimale par contre nécessite à la\r\nfois des modifications sur le processus de build et sur la configuration des\r\nserveurs.\r\n\r\nToutes ces modifications sont relativement peu couteuses à mettre en place et\r\nne dépendent aucunement ni de la technologie utilisée pour le front-end, ni de\r\ncelle utilisée pour le back-end. Elles peuvent être mise en place quelle que\r\nsoit votre stack technique. Il n'y a donc plus aucune raison pour ne pas les\r\ndéployer dès aujourd'hui.\r\n\r\n"
}